{"idx": 327, "target": 1, "func": "private ArgumentProcessor getProcessorByService(InputStream is)\n            throws IOException {\n        InputStreamReader isr = null;\n        try {\n            try {\n                isr = new InputStreamReader(is, \"UTF-8\");\n            } catch (java.io.UnsupportedEncodingException e) {\n                isr = new InputStreamReader(is);\n            }\n            BufferedReader rd = new BufferedReader(isr);\n            String processorClassName = rd.readLine();\n            if (processorClassName != null && !\"\".equals(processorClassName)) {\n                return getProcessor(processorClassName);\n            }\n        } finally {\n            try {\n                isr.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n        return null;\n    }"}
{"idx": 328, "target": 0, "func": "public void executeTarget(String targetName) {\n        PrintStream sysOut = System.out;\n        PrintStream sysErr = System.err;\n        try {\n            sysOut.flush();\n            sysErr.flush();\n            outBuffer = new StringBuffer();\n            PrintStream out = new PrintStream(new AntOutputStream(outBuffer));\n            System.setOut(out);\n            errBuffer = new StringBuffer();\n            PrintStream err = new PrintStream(new AntOutputStream(errBuffer));\n            System.setErr(err);\n            logBuffer = new StringBuffer();\n            fullLogBuffer = new StringBuffer();\n            buildException = null;\n            project.executeTarget(targetName);\n        } finally {\n            System.setOut(sysOut);\n            System.setErr(sysErr);\n        }\n\n    }"}
{"idx": 329, "target": 1, "func": "public void testLogUTF8Echo() {\n        Project p = new Project();\n        p.init();\n        EchoTestLogger logger = new EchoTestLogger();\n        p.addBuildListener(logger);\n        Echo echo = new Echo();\n        echo.setProject(p);\n        echo.setTaskName(\"testLogUTF8Echo\");\n        echo.setMessage(\"\\u00e4\\u00a9\");\n        removeThis = new File(\"abc.txt\");\n        echo.setFile(removeThis);\n        echo.setEncoding(\"UTF-8\");\n        echo.execute();\n        FileUtils fu = FileUtils.getFileUtils();\n        try {\n        String x = FileUtils.readFully(new InputStreamReader(new FileInputStream(removeThis), \"UTF-8\" ));\n            assertEquals(x,\"\\u00e4\\u00a9\");\n        } catch (Exception exc) {\n\n        }\n    }"}
{"idx": 330, "target": 0, "func": "public void testLongLine() throws IOException, ManifestException {\n        Project p = getProject();\n        p.setUserProperty(\"test.longline\", LONG_LINE);\n        p.setUserProperty(\"test.long68name\" , LONG_68_NAME);\n        p.setUserProperty(\"test.long70name\" , LONG_70_NAME);\n        p.setUserProperty(\"test.notlongname\" , NOT_LONG_NAME);\n        p.setUserProperty(\"test.value\", VALUE);\n        executeTarget(\"testLongLine\");\n\n        Manifest manifest = getManifest(EXPANDED_MANIFEST);\n        Manifest.Section mainSection = manifest.getMainSection();\n        String classpath = mainSection.getAttributeValue(\"class-path\");\n        assertEquals(\"Class-Path attribute was not set correctly - \",\n            LONG_LINE, classpath);\n        \n        String value = mainSection.getAttributeValue(LONG_68_NAME);\n        assertEquals(\"LONG_68_NAME_VALUE_MISMATCH\", VALUE, value);\n        value = mainSection.getAttributeValue(LONG_70_NAME);\n        assertEquals(\"LONG_70_NAME_VALUE_MISMATCH\", VALUE, value);\n        value = mainSection.getAttributeValue(NOT_LONG_NAME);\n        assertEquals(\"NOT_LONG_NAME_VALUE_MISMATCH\", VALUE, value);\n        \n        BufferedReader in = new BufferedReader(new FileReader(new File(System.getProperty(\"root\"), EXPANDED_MANIFEST)));\n        \n        Set set = new HashSet();\n        String read = in.readLine();\n        while (read != null)\n        {\n            set.add(read);\n            read = in.readLine();\n        }\n        \n        assertTrue(\"Manifest file should have contained string \", set\n                .remove(\" NOT_LONG\"));\n        assertTrue(\"Manifest file should have contained string \", set\n                .remove(\" NG\"));\n        assertTrue(\"Manifest file should have contained string \", set\n                .remove(LONG_70_NAME + \": \"));\n        assertTrue(\"Manifest file should have contained string \", set\n                .remove(NOT_LONG_NAME + \": NOT_LO\"));\n    }"}
{"idx": 331, "target": 1, "func": "public void testNoSeconds() {\n        executeTarget(\"noSeconds\");\n        long time = getTargetTime();\n    }"}
{"idx": 332, "target": 1, "func": "public void testSeconds() {\n        executeTarget(\"seconds\");\n        long time=getTargetTime();\n    }"}
{"idx": 333, "target": 0, "func": "public void testFilelist() {\n        touchFile(\"testFilelist\", 662256000000L);\n    }"}
{"idx": 334, "target": 1, "func": "public void print(PrintStream ps)\n         throws IOException {\n        // We need character encoding aware printing here.\n        // So, using BufferedWriter over OutputStreamWriter instead of PrintStream\n        BufferedWriter out = null;\n        try {\n            out\n                = charset != null ? new BufferedWriter(new OutputStreamWriter(ps, charset))\n                : new BufferedWriter(new OutputStreamWriter(ps));\n            if (messageSource != null) {\n                // Read message from a file\n                FileReader freader = new FileReader(messageSource);\n\n                try {\n                    BufferedReader in = new BufferedReader(freader);\n                    String line = null;\n                    while ((line = in.readLine()) != null) {\n                        out.write(getProject().replaceProperties(line));\n                        out.newLine();\n                    }\n                } finally {\n                    freader.close();\n                }\n            } else {\n                out.write(getProject().replaceProperties(buffer.substring(0)));\n                out.newLine();\n            }\n            out.flush();\n        } finally {\n            //do not close the out writer as it is reused afterwards by the mail task\n        }\n    }"}
{"idx": 335, "target": 0, "func": "public void testPrintStreamDoesNotGetClosed() {\n        Message ms = new Message();\n        Project p = new Project();\n        ms.setProject(p);\n        ms.addText(\"hi, this is an email\");\n        FileOutputStream fis = null;\n        try {\n            fis = new FileOutputStream(f);\n            ms.print(new PrintStream(fis));\n            fis.write(120);\n        } catch (IOException ioe) {\n            fail(\"we should not have issues writing after having called Message.print\");\n        } finally {\n            FileUtils.close(fis);\n        }\n\n    }"}
{"idx": 336, "target": 1, "func": "protected void attach(File file, PrintStream out)\n         throws IOException {\n        if (!file.exists() || !file.canRead()) {\n            throw new BuildException(\"File \\\"\" + file.getName()\n                 + \"\\\" does not exist or is not \"\n                 + \"readable.\");\n        }\n\n        if (includeFileNames) {\n            out.println();\n\n            String filename = file.getName();\n            int filenamelength = filename.length();\n\n            out.println(filename);\n            for (int star = 0; star < filenamelength; star++) {\n                out.print('=');\n            }\n            out.println();\n        }\n\n        int length;\n        final int maxBuf = 1024;\n        byte[] buf = new byte[maxBuf];\n        FileInputStream finstr = new FileInputStream(file);\n\n        try {\n            BufferedInputStream in = new BufferedInputStream(finstr, buf.length);\n\n            while ((length = in.read(buf)) != -1) {\n                out.write(buf, 0, length);\n            }\n        } finally {\n            finstr.close();\n        }\n    }"}
{"idx": 337, "target": 0, "func": "@Override\n    public Process exec(Project project, String[] cmd, String[] env,\n                        File workingDir) throws IOException {\n        File commandDir = workingDir;\n        if (workingDir == null) {\n            if (project != null) {\n                commandDir = project.getBaseDir();\n            } else {\n                return exec(project, cmd, env);\n            }\n        }\n        // Use cmd.exe to change to the specified drive and\n        // directory before running the command\n        final int preCmdLength = 7;\n        final String cmdDir = commandDir.getAbsolutePath();\n        String[] newcmd = new String[cmd.length + preCmdLength];\n        // CheckStyle:MagicNumber OFF - do not bother\n        newcmd[0] = \"cmd\";\n        newcmd[1] = \"/c\";\n        newcmd[2] = cmdDir.substring(0, 2);\n        newcmd[3] = \"&&\";\n        newcmd[4] = \"cd\";\n        newcmd[5] = cmdDir.substring(2);\n        newcmd[6] = \"&&\";\n        // CheckStyle:MagicNumber ON\n        System.arraycopy(cmd, 0, newcmd, preCmdLength, cmd.length);\n\n        return exec(project, newcmd, env);\n    }"}
{"idx": 338, "target": 0, "func": "@Override\n    public Process exec(Project project, String[] cmd, String[] env,\n                        File workingDir) throws IOException {\n        if (project == null) {\n            if (workingDir == null) {\n                return exec(project, cmd, env);\n            }\n            throw new IOException(\"Cannot locate antRun script: \"\n                                  + \"No project provided\");\n        }\n        // Locate the auxiliary script\n        String antHome = project.getProperty(MagicNames.ANT_HOME);\n        if (antHome == null) {\n            throw new IOException(\"Cannot locate antRun script: \"\n                                  + \"Property '\" + MagicNames.ANT_HOME\n                                  + \"' not found\");\n        }\n        String antRun = FILE_UTILS.resolveFile(project.getBaseDir(),\n                                               antHome + File.separator\n                                               + myScript).toString();\n\n        // Build the command\n        File commandDir = workingDir;\n        if (workingDir == null) {\n            commandDir = project.getBaseDir();\n        }\n        // CheckStyle:MagicNumber OFF\n        String[] newcmd = new String[cmd.length + 3];\n        newcmd[0] = \"perl\";\n        newcmd[1] = antRun;\n        newcmd[2] = commandDir.getAbsolutePath();\n        System.arraycopy(cmd, 0, newcmd, 3, cmd.length);\n        // CheckStyle:MagicNumber ON\n\n        return exec(project, newcmd, env);\n    }"}
{"idx": 339, "target": 1, "func": "public void testEchoToGoodFileXml() throws Exception {\n        executeTarget( \"testEchoToGoodFileXml\" );\n\n        // read in the file\n        File f = createRelativeFile( GOOD_OUTFILE_XML );\n        FileReader fr = new FileReader( f );\n        try {\n            BufferedReader br = new BufferedReader( fr );\n            String read = null;\n            while ( (read = br.readLine()) != null) {\n                if (read.indexOf(\"<property name=\\\"test.property\\\" value=\\\"\"+TEST_VALUE+\"\\\" />\") >= 0) {\n                    // found the property we set - it's good.\n                    return;\n                }\n            }\n            fail( \"did not encounter set property in generated file.\" );\n        } finally {\n            try {\n                fr.close();\n            } catch(IOException e) {}\n        }\n    }"}
{"idx": 340, "target": 1, "func": "private void readFile() throws BuildException {\n        if (useJDKProperties) {\n            // user chose to use standard Java properties, which loose\n            // comments and layout\n            properties = new Properties();\n        } else {\n            properties = new LayoutPreservingProperties();\n        }\n        try {\n            if (propertyfile.exists()) {\n                log(\"Updating property file: \"\n                    + propertyfile.getAbsolutePath());\n                FileInputStream fis = null;\n                try {\n                    fis = new FileInputStream(propertyfile);\n                    BufferedInputStream bis = new BufferedInputStream(fis);\n                    properties.load(bis);\n                } finally {\n                    if (fis != null) {\n                        fis.close();\n                    }\n                }\n            } else {\n                log(\"Creating new property file: \"\n                    + propertyfile.getAbsolutePath());\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(propertyfile.getAbsolutePath());\n                    out.flush();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        } catch (IOException ioe) {\n            throw new BuildException(ioe.toString());\n        }\n    }"}
{"idx": 341, "target": 0, "func": "private void readFile() throws BuildException {\n        if (useJDKProperties) {\n            // user chose to use standard Java properties, which loose\n            // comments and layout\n            properties = new Properties();\n        } else {\n            properties = new LayoutPreservingProperties();\n        }\n        try {\n            if (propertyfile.exists()) {\n                log(\"Updating property file: \"\n                    + propertyfile.getAbsolutePath());\n                FileInputStream fis = null;\n                try {\n                    fis = new FileInputStream(propertyfile);\n                    BufferedInputStream bis = new BufferedInputStream(fis);\n                    properties.load(bis);\n                } finally {\n                    if (fis != null) {\n                        fis.close();\n                    }\n                }\n            } else {\n                log(\"Creating new property file: \"\n                    + propertyfile.getAbsolutePath());\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(propertyfile.getAbsolutePath());\n                    out.flush();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        } catch (IOException ioe) {\n            throw new BuildException(ioe.toString());\n        }\n    }"}
{"idx": 342, "target": 0, "func": "public int getCalendarField() {\n            String key = getValue().toLowerCase();\n            Integer i = (Integer) calendarFields.get(key);\n            return i.intValue();\n        }"}
{"idx": 343, "target": 1, "func": "private void checkCommandLines(String[] sTestCmdLine, String[] sGeneratedCmdLine) {\n        int testLength = sTestCmdLine.length;\n        int genLength = sGeneratedCmdLine.length;\n\n        int genIndex = 0;\n        int testIndex = 0;\n\n        while (testIndex < testLength) {\n            try {\n                if (sGeneratedCmdLine[genIndex] == \"\") {\n                    genIndex++;\n                    continue;\n                }\n                assertEquals(\"arg # \" + testIndex,\n                        sTestCmdLine[testIndex],\n                        sGeneratedCmdLine[genIndex]);\n                testIndex++;\n                genIndex++;\n            } catch (ArrayIndexOutOfBoundsException aioob) {\n                fail(\"missing arg \" + sTestCmdLine[testIndex]);\n            }\n        }\n\n        // Count the number of empty strings\n        int cnt = 0;\n        for (int i = 0; i < genLength; i++) {\n            if (sGeneratedCmdLine[i] == \"\") {\n                cnt++;\n            }\n        }\n        if (genLength - cnt > sTestCmdLine.length) {\n            // We have extra elements\n            fail(\"extra args\");\n        }\n    }"}
{"idx": 344, "target": 0, "func": "public void testGetCommandLine() {\n        String[] sTestCmdLine = {MSVSS.SS_EXE, MSVSS.COMMAND_GET, DS_VSS_PROJECT_PATH,\n                MSVSS.FLAG_OVERRIDE_WORKING_DIR + project.getBaseDir().getAbsolutePath()\n                 + File.separator + LOCAL_PATH, MSVSS.FLAG_AUTORESPONSE_DEF,\n                MSVSS.FLAG_RECURSION, MSVSS.FLAG_VERSION + VERSION, MSVSS.FLAG_LOGIN\n                 + VSS_USERNAME + \",\" + VSS_PASSWORD, FLAG_FILETIME_UPDATED, FLAG_SKIP_WRITABLE};\n\n        // Set up a VSSGet task\n        MSVSSGET vssGet = new MSVSSGET();\n        vssGet.setProject(project);\n        vssGet.setRecursive(true);\n        vssGet.setLocalpath(new Path(project, LOCAL_PATH));\n        vssGet.setLogin(VSS_USERNAME + \",\" + VSS_PASSWORD);\n        vssGet.setVersion(VERSION);\n        vssGet.setQuiet(false);\n        vssGet.setDate(DATE);\n        vssGet.setLabel(SRC_LABEL);\n        vssGet.setVsspath(VSS_PROJECT_PATH);\n        MSVSS.CurrentModUpdated cmu = new MSVSS.CurrentModUpdated();\n        cmu.setValue(TIME_UPDATED);\n        vssGet.setFileTimeStamp(cmu);\n        MSVSS.WritableFiles wf = new MSVSS.WritableFiles();\n        wf.setValue(WRITABLE_SKIP);\n        vssGet.setWritableFiles(wf);\n\n        commandline = vssGet.buildCmdLine();\n\n        checkCommandLines(sTestCmdLine, commandline.getCommandline());\n    }"}
{"idx": 345, "target": 1, "func": "public void testGetCommandline() throws Exception {\n        CommandlineJava c = new CommandlineJava();\n        c.createArgument().setValue(\"org.apache.tools.ant.CommandlineJavaTest\");\n        c.setClassname(\"junit.textui.TestRunner\");\n        c.createVmArgument().setValue(\"-Djava.compiler=NONE\");\n        String[] s = c.getCommandline();\n        assertEquals(\"no classpath\", 4, s.length);\n        /*\n         * After changing CommandlineJava to search for the java\n         * executable, I don't know, how to tests the value returned\n         * here without using the same logic as applied in the class\n         * itself.\n         *\n         * assertTrue(\"no classpath\", \"java\", s[0]);\n         */\n        assertEquals(\"no classpath\", \"-Djava.compiler=NONE\", s[1]);\n        assertEquals(\"no classpath\", \"junit.textui.TestRunner\", s[2]);\n        assertEquals(\"no classpath\",\n                     \"org.apache.tools.ant.CommandlineJavaTest\", s[3]);\n        try {\n            CommandlineJava c2 = (CommandlineJava) c.clone();\n        } catch (NullPointerException ex) {\n            fail(\"cloning should work without classpath specified\");\n        }\n\n        c.createClasspath(project).setLocation(project.resolveFile(\"build.xml\"));\n        c.createClasspath(project).setLocation(project.resolveFile(\n            System.getProperty(MagicNames.ANT_HOME)+\"/lib/ant.jar\"));\n        s = c.getCommandline();\n        assertEquals(\"with classpath\", 6, s.length);\n        //        assertEquals(\"with classpath\", \"java\", s[0]);\n        assertEquals(\"with classpath\", \"-Djava.compiler=NONE\", s[1]);\n        assertEquals(\"with classpath\", \"-classpath\", s[2]);\n        assertTrue(\"build.xml contained\",\n               s[3].indexOf(\"build.xml\"+java.io.File.pathSeparator) >= 0);\n        assertTrue(\"ant.jar contained\", s[3].endsWith(\"ant.jar\"));\n        assertEquals(\"with classpath\", \"junit.textui.TestRunner\", s[4]);\n        assertEquals(\"with classpath\",\n                     \"org.apache.tools.ant.CommandlineJavaTest\", s[5]);\n    }"}
{"idx": 346, "target": 0, "func": "public void testGetCommandline() throws Exception {\n        CommandlineJava c = new CommandlineJava();\n        c.createArgument().setValue(\"org.apache.tools.ant.CommandlineJavaTest\");\n        c.setClassname(\"junit.textui.TestRunner\");\n        c.createVmArgument().setValue(\"-Djava.compiler=NONE\");\n        String[] s = c.getCommandline();\n        assertEquals(\"no classpath\", 4, s.length);\n        /*\n         * After changing CommandlineJava to search for the java\n         * executable, I don't know, how to tests the value returned\n         * here without using the same logic as applied in the class\n         * itself.\n         *\n         * assertTrue(\"no classpath\", \"java\", s[0]);\n         */\n        assertEquals(\"no classpath\", \"-Djava.compiler=NONE\", s[1]);\n        assertEquals(\"no classpath\", \"junit.textui.TestRunner\", s[2]);\n        assertEquals(\"no classpath\",\n                     \"org.apache.tools.ant.CommandlineJavaTest\", s[3]);\n        try {\n            CommandlineJava c2 = (CommandlineJava) c.clone();\n        } catch (NullPointerException ex) {\n            fail(\"cloning should work without classpath specified\");\n        }\n\n        c.createClasspath(project).setLocation(project.resolveFile(\"build.xml\"));\n        c.createClasspath(project).setLocation(project.resolveFile(\n            System.getProperty(MagicNames.ANT_HOME)+\"/lib/ant.jar\"));\n        s = c.getCommandline();\n        assertEquals(\"with classpath\", 6, s.length);\n        //        assertEquals(\"with classpath\", \"java\", s[0]);\n        assertEquals(\"with classpath\", \"-Djava.compiler=NONE\", s[1]);\n        assertEquals(\"with classpath\", \"-classpath\", s[2]);\n        assertTrue(\"build.xml contained\",\n               s[3].indexOf(\"build.xml\"+java.io.File.pathSeparator) >= 0);\n        assertTrue(\"ant.jar contained\", s[3].endsWith(\"ant.jar\"));\n        assertEquals(\"with classpath\", \"junit.textui.TestRunner\", s[4]);\n        assertEquals(\"with classpath\",\n                     \"org.apache.tools.ant.CommandlineJavaTest\", s[5]);\n    }"}
{"idx": 347, "target": 0, "func": "public void testSysproperties() {\n        String currentClasspath = System.getProperty(\"java.class.path\");\n        assertNotNull(currentClasspath);\n        assertNull(System.getProperty(\"key\"));\n        CommandlineJava c = new CommandlineJava();\n        Environment.Variable v = new Environment.Variable();\n        v.setKey(\"key\");\n        v.setValue(\"value\");\n        c.addSysproperty(v);\n\n        project.setProperty(\"key2\", \"value2\");\n        PropertySet ps = new PropertySet();\n        ps.setProject(project);\n        ps.appendName(\"key2\");\n        c.addSyspropertyset(ps);\n\n        try {\n            c.setSystemProperties();\n            String newClasspath = System.getProperty(\"java.class.path\");\n            assertNotNull(newClasspath);\n            assertEquals(currentClasspath, newClasspath);\n            assertNotNull(System.getProperty(\"key\"));\n            assertEquals(\"value\", System.getProperty(\"key\"));\n            assertTrue(System.getProperties().containsKey(\"java.class.path\"));\n            assertNotNull(System.getProperty(\"key2\"));\n            assertEquals(\"value2\", System.getProperty(\"key2\"));\n        } finally {\n            c.restoreSystemProperties();\n        }\n        assertNull(System.getProperty(\"key\"));\n        assertNull(System.getProperty(\"key2\"));\n    }"}
{"idx": 348, "target": 1, "func": "public void tearDown() {\n            executeTarget(\"cleanup\");\n        }"}
{"idx": 349, "target": 1, "func": "public void testNullPointer() throws IOException {\n        try {\n            CBZip2InputStream cb = new CBZip2InputStream(new ByteArrayInputStream(new byte[0]));\n            fail(\"expected an exception\");\n        } catch (IOException e) {\n            // expected\n        }\n    }"}
{"idx": 350, "target": 0, "func": "public void replyto(String rto) {\n      this.replyto.addElement(rto);\n    }"}
{"idx": 351, "target": 0, "func": "public void testAsciiCharset() {\n\n        ServerThread testMailServer = new ServerThread();\n        Thread server = new Thread(testMailServer);\n        server.start();\n\n        ClientThread testMailClient = new ClientThread();\n\n        testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\");\n        testMailClient.to(\"Ceki G\\u00fclc\\u00fc <abuse@mail-abuse.org>\");\n        testMailClient.setSubject(\"Test subject\");\n        testMailClient.setMessage(\"\");\n\n        Thread client = new Thread(testMailClient);\n        client.start();\n\n        try {\n            server.join(60 * 1000); // 60s\n            client.join(30 * 1000); // a further 30s\n        } catch (InterruptedException ie ) {\n            fail(\"InterruptedException: \" + ie);\n        }\n\n        String result = testMailServer.getResult();\n        String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" +\n        \"HELO \" + local + \"\\r\\n\" +\n        \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" +\n        \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" +\n        \"250\\r\\n\" +\n        \"RCPT TO: <abuse@mail-abuse.org>\\r\\n\" +\n        \"250\\r\\n\" +\n        \"DATA\\r\\n\" +\n        \"354\\r\\n\" +\n        \"Subject: Test subject\\r\\n\" +\n            \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" +\n            \"To: Ceki G\\u00fclc\\u00fc <abuse@mail-abuse.org>\\r\\n\" +\n        \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" +\n        \"\\r\\n\" +\n        \"\\r\\n\" +\n        \"\\r\\n\" +\n        \".\\r\\n\" +\n        \"250\\r\\n\" +\n        \"QUIT\\r\\n\" +\n        \"221\\r\\n\";\n        ByteArrayOutputStream baos1 = new ByteArrayOutputStream();\n        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();\n        PrintStream bos1 = new PrintStream(baos1, true);\n        PrintStream bos2 = new PrintStream(baos2, true);\n\n        bos1.print(expectedResult);\n        bos2.print(result);\n\n        assertEquals( \"expected message length != actual message length \"\n            + \"in testAsciiCharset()\", expectedResult.length(), result.length() );\n        assertEquals( \"baos1 and baos2 should be the same in testAsciiCharset()\",\n            baos1.toString(), baos2.toString() ); // order of headers cannot be guaranteed\n        if (testMailClient.isFailed()) {\n            fail(testMailClient.getFailMessage());\n        }\n    }"}
{"idx": 352, "target": 1, "func": "public void validate(String token) throws ConfigurationException\n        {\n            try\n            {\n                Long i = Long.valueOf(token);\n            }\n            catch (NumberFormatException e)\n            {\n                throw new ConfigurationException(e.getMessage());\n            }\n        }"}
{"idx": 353, "target": 0, "func": "public StringToken midpoint(Token ltoken, Token rtoken)\n    {\n        int sigchars = Math.max(((StringToken)ltoken).token.length(), ((StringToken)rtoken).token.length());\n        BigInteger left = bigForString(((StringToken)ltoken).token, sigchars);\n        BigInteger right = bigForString(((StringToken)rtoken).token, sigchars);\n\n        Pair<BigInteger,Boolean> midpair = FBUtilities.midpoint(left, right, 16*sigchars);\n        return new StringToken(stringForBig(midpair.left, sigchars, midpair.right));\n    }"}
{"idx": 354, "target": 1, "func": "public static Options parseArgs(String cmdArgs[])\n        {\n            CommandLineParser parser = new GnuParser();\n            CmdLineOptions options = getCmdLineOptions();\n            try\n            {\n                CommandLine cmd = parser.parse(options, cmdArgs, false);\n\n                if (cmd.hasOption(HELP_OPTION))\n                {\n                    printUsage(options);\n                    System.exit(0);\n                }\n\n                String[] args = cmd.getArgs();\n                if (args.length == 0)\n                {\n                    System.err.println(\"No sstables to split\");\n                    printUsage(options);\n                    System.exit(1);\n                }\n                Options opts = new Options(Arrays.asList(args));\n                opts.debug = cmd.hasOption(DEBUG_OPTION);\n                opts.verbose = cmd.hasOption(VERBOSE_OPTION);\n                opts.snapshot = !cmd.hasOption(NO_SNAPSHOT_OPTION);\n                opts.sizeInMB = DEFAULT_SSTABLE_SIZE;\n\n                if (cmd.hasOption(SIZE_OPTION))\n                    opts.sizeInMB = Integer.valueOf(cmd.getOptionValue(SIZE_OPTION));\n\n                return opts;\n            }\n            catch (ParseException e)\n            {\n                errorMsg(e.getMessage(), options);\n                return null;\n            }\n        }"}
{"idx": 355, "target": 0, "func": "private static void errorMsg(String msg, CmdLineOptions options)\n        {\n            System.err.println(msg);\n            printUsage(options);\n            System.exit(1);\n        }"}
{"idx": 356, "target": 0, "func": "public static Options parseArgs(String cmdArgs[])\n        {\n            CommandLineParser parser = new GnuParser();\n            CmdLineOptions options = getCmdLineOptions();\n            try\n            {\n                CommandLine cmd = parser.parse(options, cmdArgs, false);\n\n                if (cmd.hasOption(HELP_OPTION))\n                {\n                    printUsage(options);\n                    System.exit(0);\n                }\n\n                String[] args = cmd.getArgs();\n                if (args.length == 0)\n                {\n                    System.err.println(\"No sstables to split\");\n                    printUsage(options);\n                    System.exit(1);\n                }\n                Options opts = new Options(Arrays.asList(args));\n                opts.debug = cmd.hasOption(DEBUG_OPTION);\n                opts.verbose = cmd.hasOption(VERBOSE_OPTION);\n                opts.snapshot = !cmd.hasOption(NO_SNAPSHOT_OPTION);\n                opts.sizeInMB = DEFAULT_SSTABLE_SIZE;\n\n                if (cmd.hasOption(SIZE_OPTION))\n                    opts.sizeInMB = Integer.valueOf(cmd.getOptionValue(SIZE_OPTION));\n\n                return opts;\n            }\n            catch (ParseException e)\n            {\n                errorMsg(e.getMessage(), options);\n                return null;\n            }\n        }"}
{"idx": 357, "target": 1, "func": "public static String wrapCharArray(char[] c)\n    {\n        if (c == null)\n            return null;\n\n        String s = null;\n\n        if (stringConstructor != null)\n        {\n            try\n            {\n                s = stringConstructor.newInstance(0, c.length, c);\n            }\n            catch (Exception e)\n            {\n                // Swallowing as we'll just use a copying constructor\n            }\n        }\n        return s == null ? new String(c) : s;\n    }"}
{"idx": 358, "target": 0, "func": "@Override\n                    public Class<?> next() {\n                        final Class<?> result = next.getValue();\n                        next.setValue(result.getSuperclass());\n                        return result;\n                    }"}
{"idx": 359, "target": 0, "func": "public static String lowerCase(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }"}
{"idx": 360, "target": 1, "func": "private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos, false);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }"}
{"idx": 361, "target": 0, "func": "@Override\n    public final void applyPattern(final String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        final ArrayList<Format> foundFormats = new ArrayList<Format>();\n        final ArrayList<String> foundDescriptions = new ArrayList<String>();\n        final StringBuilder stripCustom = new StringBuilder(pattern.length());\n\n        final ParsePosition pos = new ParsePosition(0);\n        final char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                final int start = pos.getIndex();\n                final int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                //$FALL-THROUGH$\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            final Format[] origFormats = getFormats();\n            // only loop over what we know we have, as MessageFormat on Java 1.3\n            // seems to provide an extra format element:\n            int i = 0;\n            for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n                final Format f = it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }"}
{"idx": 362, "target": 1, "func": "private static long getFragment(final Date date, final int fragment, final int unit) {\n        if(date == null) {\n            throw  new IllegalArgumentException(\"The date must not be null\");\n        }\n        final Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        return getFragment(calendar, fragment, unit);\n    }"}
{"idx": 363, "target": 1, "func": "public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        final Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }"}
{"idx": 364, "target": 1, "func": "private static void modify(final Calendar val, final int field, final int modType) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        final Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        final int millisecs = val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n            time = time - millisecs;\n        }\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n\n        // truncate seconds\n        final int seconds = val.get(Calendar.SECOND);\n        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        }\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n\n        // truncate minutes\n        final int minutes = val.get(Calendar.MINUTE);\n        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (final int[] aField : fields) {\n            for (final int element : aField) {\n                if (element == field) {\n                    //This is our field... we stop looping\n                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field == Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (aField[0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset >= 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                final int min = val.getActualMinimum(aField[0]);\n                final int max = val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }"}
{"idx": 365, "target": 1, "func": "static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,\n            int milliseconds, final boolean padWithZeros) {\n        final StringBuilder buffer = new StringBuilder();\n        boolean lastOutputSeconds = false;\n        final int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            final Token token = tokens[i];\n            final Object value = token.getValue();\n            final int count = token.getCount();\n            if (value instanceof StringBuilder) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        final String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }"}
{"idx": 366, "target": 1, "func": "static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,\n            int milliseconds, final boolean padWithZeros) {\n        final StringBuilder buffer = new StringBuilder();\n        boolean lastOutputSeconds = false;\n        final int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            final Token token = tokens[i];\n            final Object value = token.getValue();\n            final int count = token.getCount();\n            if (value instanceof StringBuilder) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        final String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }"}
{"idx": 367, "target": 1, "func": "static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,\n            int milliseconds, final boolean padWithZeros) {\n        final StringBuilder buffer = new StringBuilder();\n        boolean lastOutputSeconds = false;\n        final int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            final Token token = tokens[i];\n            final Object value = token.getValue();\n            final int count = token.getCount();\n            if (value instanceof StringBuilder) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        final String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }"}
{"idx": 368, "target": 1, "func": "static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,\n            int milliseconds, final boolean padWithZeros) {\n        final StringBuilder buffer = new StringBuilder();\n        boolean lastOutputSeconds = false;\n        final int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            final Token token = tokens[i];\n            final Object value = token.getValue();\n            final int count = token.getCount();\n            if (value instanceof StringBuilder) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        final String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }"}
{"idx": 369, "target": 1, "func": "static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,\n            int milliseconds, final boolean padWithZeros) {\n        final StringBuilder buffer = new StringBuilder();\n        boolean lastOutputSeconds = false;\n        final int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            final Token token = tokens[i];\n            final Object value = token.getValue();\n            final int count = token.getCount();\n            if (value instanceof StringBuilder) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        final String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }"}
{"idx": 370, "target": 1, "func": "static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,\n            int milliseconds, final boolean padWithZeros) {\n        final StringBuilder buffer = new StringBuilder();\n        boolean lastOutputSeconds = false;\n        final int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            final Token token = tokens[i];\n            final Object value = token.getValue();\n            final int count = token.getCount();\n            if (value instanceof StringBuilder) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        final String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }"}
{"idx": 371, "target": 1, "func": "static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,\n            int milliseconds, final boolean padWithZeros) {\n        final StringBuilder buffer = new StringBuilder();\n        boolean lastOutputSeconds = false;\n        final int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            final Token token = tokens[i];\n            final Object value = token.getValue();\n            final int count = token.getCount();\n            if (value instanceof StringBuilder) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        final String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }"}
{"idx": 372, "target": 1, "func": "static Token[] lexx(final String format) {\n        final char[] array = format.toCharArray();\n        final ArrayList<Token> list = new ArrayList<Token>(array.length);\n\n        boolean inLiteral = false;\n        // Although the buffer is stored in a Token, the Tokens are only\n        // used internally, so cannot be accessed by other threads\n        StringBuilder buffer = null;\n        Token previous = null;\n        final int sz = array.length;\n        for (int i = 0; i < sz; i++) {\n            final char ch = array[i];\n            if (inLiteral && ch != '\\'') {\n                buffer.append(ch); // buffer can't be null if inLiteral is true\n                continue;\n            }\n            Object value = null;\n            switch (ch) {\n            // TODO: Need to handle escaping of '\n            case '\\'':\n                if (inLiteral) {\n                    buffer = null;\n                    inLiteral = false;\n                } else {\n                    buffer = new StringBuilder();\n                    list.add(new Token(buffer));\n                    inLiteral = true;\n                }\n                break;\n            case 'y':\n                value = y;\n                break;\n            case 'M':\n                value = M;\n                break;\n            case 'd':\n                value = d;\n                break;\n            case 'H':\n                value = H;\n                break;\n            case 'm':\n                value = m;\n                break;\n            case 's':\n                value = s;\n                break;\n            case 'S':\n                value = S;\n                break;\n            default:\n                if (buffer == null) {\n                    buffer = new StringBuilder();\n                    list.add(new Token(buffer));\n                }\n                buffer.append(ch);\n            }\n\n            if (value != null) {\n                if (previous != null && previous.getValue() == value) {\n                    previous.increment();\n                } else {\n                    final Token token = new Token(value);\n                    list.add(token);\n                    previous = token;\n                }\n                buffer = null;\n            }\n        }\n        return list.toArray(new Token[list.size()]);\n    }"}
{"idx": 373, "target": 0, "func": "public static String formatPeriod(final long startMillis, final long endMillis, final String format) {\n        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n    }"}
{"idx": 374, "target": 0, "func": "private Strategy getStrategy(String formatField, final Calendar definingCalendar) {\n        switch(formatField.charAt(0)) {\n        case '\\'':\n            if(formatField.length()>2) {\n                formatField= formatField.substring(1, formatField.length()-1);\n            }\n            //$FALL-THROUGH$\n        default:\n            return new CopyQuotedStrategy(formatField);\n        case 'D':\n            return DAY_OF_YEAR_STRATEGY;\n        case 'E':\n            return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar);\n        case 'F':\n            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n        case 'G':\n            return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar);\n        case 'H':\n            return MODULO_HOUR_OF_DAY_STRATEGY;\n        case 'K':\n            return HOUR_STRATEGY;\n        case 'M':\n            return formatField.length()>=3 ?getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) :NUMBER_MONTH_STRATEGY;\n        case 'S':\n            return MILLISECOND_STRATEGY;\n        case 'W':\n            return WEEK_OF_MONTH_STRATEGY;\n        case 'a':\n            return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar);\n        case 'd':\n            return DAY_OF_MONTH_STRATEGY;\n        case 'h':\n            return MODULO_HOUR_STRATEGY;\n        case 'k':\n            return HOUR_OF_DAY_STRATEGY;\n        case 'm':\n            return MINUTE_STRATEGY;\n        case 's':\n            return SECOND_STRATEGY;\n        case 'w':\n            return WEEK_OF_YEAR_STRATEGY;\n        case 'y':\n            return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n        case 'Z':\n        case 'z':\n            return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar);\n        }\n    }"}
{"idx": 375, "target": 0, "func": "@Override\n        public boolean equals(final Object obj) {\n            // Eliminate the usual boilerplate because\n            // this inner static class is only used in a generic ConcurrentHashMap\n            // which will not compare against other Object types\n            return Arrays.equals(keys, ((MultipartKey)obj).keys);\n        }"}
{"idx": 376, "target": 0, "func": "@Override\n        public boolean equals(final Object obj) {\n            // Eliminate the usual boilerplate because\n            // this inner static class is only used in a generic ConcurrentHashMap\n            // which will not compare against other Object types\n            return Arrays.equals(keys, ((MultipartKey)obj).keys);\n        }"}
{"idx": 377, "target": 0, "func": "public  int[] \tgetUpdateCounts() { return null; }"}
{"idx": 378, "target": 0, "func": "public  String \ttoString()  { return null; }"}
{"idx": 379, "target": 0, "func": "public  String \tgetSQLState() { return null; }"}
{"idx": 380, "target": 0, "func": "public  String \ttoString() { return null; }"}
{"idx": 381, "target": 0, "func": "public  int \tcompareTo(Date o)   { return 0; }"}
{"idx": 382, "target": 0, "func": "public  boolean \tequals(Object ts)   { return false; }"}
{"idx": 383, "target": 0, "func": "public  String \ttoString()  { return null; }"}
{"idx": 384, "target": 1, "func": "public InputStream getBinaryStream() throws SQLException {\n        return new ByteArrayInputStream(buf);\n    }"}
{"idx": 385, "target": 0, "func": "public byte[] getBytes(long pos, int length) throws SQLException {\n\n        if (pos < 1 || pos > len)\n        {\n            throw makeSQLException( SQLState.BLOB_BAD_POSITION, new Object[] {new Long(pos)} );\n        }\n        if (length < 0)\n        {\n            throw makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Integer(length)} );\n        }\n\n        if (length > len - pos + 1) {\n            length = (int) (len - pos + 1);\n        }\n        byte[] copiedArray = new byte[length];\n        System.arraycopy(buf, (int) pos - 1, copiedArray, 0, length);\n        return copiedArray;\n    }"}
{"idx": 386, "target": 0, "func": "public Object\tgetObject() \n\t{\n\t\tif (isNull())\n\t\t\treturn null;\n\t\telse\n\t\t\treturn new Integer(value);\n\t}"}
{"idx": 387, "target": 0, "func": "public int hashCode()\n\t{\n\t\treturn (int) value;\n\t}"}
{"idx": 388, "target": 1, "func": "protected List evalXQExpression(XMLDataValue xmlContext,\n        boolean returnResults, int [] resultXType) throws Exception\n    {\n        // if this object is in an SPS, we need to recompile the query\n        if (recompileQuery)\n        {\n        \tcompileXQExpr(queryExpr, opName);\n        }\n\n        // Make sure we have a compiled query.\n        if (SanityManager.DEBUG) {\n            SanityManager.ASSERT(\n                (query != null),\n                \"Failed to locate compiled XML query expression.\");\n        }\n\n        /* Create a DOM node from the xmlContext, since that's how\n         * we feed the context to Xalan.  We do this by creating\n         * a Document node using DocumentBuilder, which means that\n         * the serialized form of the context node must be a string\n         * value that is parse-able by DocumentBuilder--i.e. it must\n         * constitute a valid XML document.  If that's true then\n         * the context item's qualified type will be DOC_ANY.\n         */\n        if (xmlContext.getXType() != XML.XML_DOC_ANY)\n        {\n            throw StandardException.newException(\n                SQLState.LANG_INVALID_XML_CONTEXT_ITEM,\n                (returnResults ? \"XMLQUERY\" : \"XMLEXISTS\"));\n        } \n\n        Document docNode = null;\n        docNode = dBuilder.parse(\n            new InputSource(\n                new StringReader(xmlContext.getString())));\n\n        // Evaluate the expresion using Xalan.\n        XPathResult result = (XPathResult)\n                query.evaluate(docNode, XPathResult.ANY_TYPE, null);\n\n        if (!returnResults)\n        {\n            // We don't want to return the actual results, we just\n            // want to know if there was at least one item in the\n            // result sequence.\n            switch (result.getResultType()) {\n                case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:\n                case XPathResult.ORDERED_NODE_ITERATOR_TYPE:\n                    if (result.iterateNext() == null) {\n                        // We have an empty sequence, so return null.\n                        return null;\n                    } else {\n                        // We have a non-empty sequence, so return a non-null\n                        // list to indicate that we found at least one item.\n                        return Collections.EMPTY_LIST;\n                    }\n                default:\n                    // We have a single atomic value, which means the result is\n                    // non-empty. So return a non-null list.\n                    return Collections.EMPTY_LIST;\n            }\n        }\n\n        // Else process the results.\n        List itemRefs;\n        switch (result.getResultType()) {\n            case XPathResult.NUMBER_TYPE:\n                // Single atomic number. Get its string value.\n                String val = numberToString(result.getNumberValue());\n                itemRefs = Collections.singletonList(val);\n                break;\n            case XPathResult.STRING_TYPE:\n                // Single atomic string value.\n                itemRefs = Collections.singletonList(result.getStringValue());\n                break;\n            case XPathResult.BOOLEAN_TYPE:\n                // Single atomic boolean. Get its string value.\n                itemRefs = Collections.singletonList(\n                        String.valueOf(result.getBooleanValue()));\n                break;\n            case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:\n            case XPathResult.ORDERED_NODE_ITERATOR_TYPE:\n                // We have a sequence. Get all nodes.\n                ArrayList<Node> nodes = new ArrayList<Node>();\n                Node node;\n                while ((node = result.iterateNext()) != null) {\n                    nodes.add(node);\n                }\n                itemRefs = nodes;\n                break;\n            default:\n                if (SanityManager.DEBUG) {\n                    SanityManager.THROWASSERT(\n                            \"Don't know how to handle XPath result type \" +\n                            result.getResultType());\n                }\n                itemRefs = null;\n        }\n\n        /* Indicate what kind of XML result value we have.  If\n         * we have a sequence of exactly one Document then it\n         * is XMLPARSE-able and so we consider it to be of type\n         * XML_DOC_ANY (which means we can store it in a Derby\n         * XML column).\n         */\n        if ((itemRefs.size() == 1) && (itemRefs.get(0) instanceof Document))\n            resultXType[0] = XML.XML_DOC_ANY;\n        else\n            resultXType[0] = XML.XML_SEQUENCE;\n\n        return itemRefs;\n    }"}
{"idx": 389, "target": 1, "func": "private void compareConstraintModes(\n            SQLSessionContext nested,\n            SQLSessionContext caller) throws StandardException {\n\n        if (deferredHashTables == null) {\n            // Nothing to do\n            return;\n        }\n\n        DataDictionary dd = getDataDictionary();\n\n        // Check all constraints that were deferred inside the routine\n        // but whose constraint mode is immediate on the outside. If\n        // any of these violate the constraints, roll back.\n        Set<Map.Entry<Long, BackingStoreHashtable>> es =\n                deferredHashTables.entrySet();\n\n        for (Map.Entry<Long, BackingStoreHashtable> e : es) {\n            final long indexCID = e.getKey().longValue();\n\n            boolean effectivelyDeferred = effectivelyDeferred(caller, indexCID);\n\n            if (effectivelyDeferred ) {\n                // the constraint is also deferred in the calling context\n                continue;\n            }\n            // The constraint must have been deferred inside the routine\n            if (SanityManager.DEBUG) {\n                SanityManager.ASSERT(effectivelyDeferred(nested, indexCID));\n            }\n\n            doValidateConstraint(e.getKey().longValue(), e.getValue(), true);\n        }\n    }"}
{"idx": 390, "target": 0, "func": "public boolean verifyAllHeldResultSetsAreClosed()\n            throws StandardException\n    {\n        boolean seenOpenResultSets = false;\n\n        /* For every activation */\n        for (int i = acts.size() - 1; i >= 0; i--) {\n\n            Activation a = acts.get(i);\n\n            if (SanityManager.DEBUG)\n            {\n                SanityManager.ASSERT(a instanceof CursorActivation, \"a is not a CursorActivation\");\n            }\n\n            if (!a.isInUse())\n            {\n                continue;\n            }\n\n            if (!a.getResultSetHoldability())\n            {\n                continue;\n            }\n\n            ResultSet rs = ((CursorActivation) a).getResultSet();\n\n            /* is there an open result set? */\n            if ((rs != null) && !rs.isClosed() && rs.returnsRows())\n            {\n                seenOpenResultSets = true;\n                break;\n            }\n        }\n\n        if (!seenOpenResultSets)\n            return(true);\n\n        // There may be open ResultSet's that are yet to be garbage collected\n        // let's try and force these out rather than throw an error\n        System.gc();\n        System.runFinalization();\n\n\n        /* For every activation */\n        for (int i = acts.size() - 1; i >= 0; i--) {\n                \n            Activation a = acts.get(i);\n\n            if (SanityManager.DEBUG)\n            {\n                SanityManager.ASSERT(a instanceof CursorActivation, \"a is not a CursorActivation\");\n            }\n\n            if (!a.isInUse())\n            {\n                continue;\n            }\n\n            if (!a.getResultSetHoldability())\n            {\n                continue;\n            }\n\n            ResultSet rs = ((CursorActivation) a).getResultSet();\n\n            /* is there an open held result set? */\n            if ((rs != null) && !rs.isClosed() && rs.returnsRows())\n            {\n                return(false);\n            }\n        }\n        return(true);\n    }"}
{"idx": 391, "target": 0, "func": "public boolean verifyNoOpenResultSets(PreparedStatement pStmt, Provider provider,\n                                       int action)\n            throws StandardException\n    {\n        /*\n        ** It is not a problem to create an index when there is an open\n        ** result set, since it doesn't invalidate the access path that was\n        ** chosen for the result set.\n        */\n        boolean seenOpenResultSets = false;\n\n        /* For every activation */\n\n        // synchronize on acts as other threads may be closing activations\n        // in this list, thus invalidating the Enumeration\n        for (int i = acts.size() - 1; i >= 0; i--) {\n                \n            Activation a = acts.get(i);\n\n            if (!a.isInUse())\n            {\n                continue;\n            }\n            \n            /* for this prepared statement */\n            if (pStmt == a.getPreparedStatement()) {\n                ResultSet rs = a.getResultSet();\n\n                /* is there an open result set? */\n                if (rs != null && ! rs.isClosed())\n                {\n                    if (!rs.returnsRows())\n                        continue;\n                    seenOpenResultSets = true;\n                    break;\n                }\n                \n            }\n        }\n\n        if (!seenOpenResultSets)\n            return false;\n\n        // There may be open ResultSet's that are yet to be garbage collected\n        // let's try and force these out rather than throw an error\n        System.gc();\n        System.runFinalization();\n\n\n        /* For every activation */\n        // synchronize on acts as other threads may be closing activations\n        // in this list, thus invalidating the Enumeration\n        for (int i = acts.size() - 1; i >= 0; i--) {\n                \n            Activation a = acts.get(i);\n\n            if (!a.isInUse())\n            {\n                continue;\n            }\n\n            /* for this prepared statement */\n            if (pStmt == a.getPreparedStatement()) {\n                ResultSet rs = a.getResultSet();\n\n                /* is there an open result set? */\n                if (rs != null && ! rs.isClosed())\n                {\n                    if ((provider != null) && rs.returnsRows()) {\n                    DependencyManager dmgr = getDataDictionary().getDependencyManager();\n\n                    throw StandardException.newException(SQLState.LANG_CANT_INVALIDATE_OPEN_RESULT_SET, \n                                    dmgr.getActionString(action), \n                                    provider.getObjectName());\n\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }"}
{"idx": 392, "target": 1, "func": "protected ScanController getScanController(long conglomNumber,\n\t\t\t\t\t\t\t\t\t\t\t   StaticCompiledOpenConglomInfo scoci,\n\t\t\t\t\t\t\t\t\t\t\t   DynamicCompiledOpenConglomInfo dcoci, ExecRow searchRow)\n\t\tthrows StandardException\n\t{\n\t\tint\t\t\t\tisoLevel = getRICheckIsolationLevel();\n\t\tScanController \tscan;\n\t\tLong\t\t\thashKey = new Long(conglomNumber);\n\n\t\t/*\n\t\t** If we haven't already opened this scan controller,\n\t\t** we'll open it now and stick it in the hash table.\n\t\t*/\n\t\tif ((scan = scanControllers.get(hashKey)) == null)\n\t\t{\n\t\t\tsetupQualifierRow(searchRow);\n\t\t\tscan = \n                tc.openCompiledScan(\n                      false,                       \t\t\t\t// hold \n                      0, \t\t\t\t\t\t\t\t\t\t// read only\n                      TransactionController.MODE_RECORD,\t\t// row locking\n\t\t\t\t\t  isoLevel,\n                      (FormatableBitSet)null, \t\t\t\t\t\t\t// retrieve all fields\n                      indexQualifierRow.getRowArray(),    \t\t// startKeyValue\n                      ScanController.GE,            \t\t\t// startSearchOp\n                      null,                         \t\t\t// qualifier\n                      indexQualifierRow.getRowArray(),    \t\t// stopKeyValue\n                      ScanController.GT,             \t\t\t// stopSearchOp \n\t\t\t\t\t  scoci,\n\t\t\t\t\t  dcoci\n                      );\n\t\t\tscanControllers.put(hashKey, scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t** If the base row is the same row as the previous\t\n\t\t\t** row, this call to setupQualfierRow is redundant,\n\t\t\t** but it is safer this way so we'll take the\n\t\t\t** marginal performance hit (marginal relative\n\t\t\t** to the index scans that we are making).\n\t\t\t*/\n\t\t\tsetupQualifierRow(searchRow);\n\t\t\tscan.reopenScan(\n                      indexQualifierRow.getRowArray(),    \t// startKeyValue\n                      ScanController.GE,            \t\t// startSearchOp\n                      null,                         \t\t// qualifier\n                      indexQualifierRow.getRowArray(), \t\t// stopKeyValue\n                      ScanController.GT             \t\t// stopSearchOp \n                      );\n\t\t}\n\n\t\treturn scan;\n\t}"}
{"idx": 393, "target": 0, "func": "static void boot() {\n        PrintWriter pw = DriverManager.getLogWriter();\n\n        if (pw == null) {\n            pw = new PrintWriter(System.err, true);\n        }\n\n        new JDBCBoot().boot(Attribute.PROTOCOL, pw);\n\t}"}
{"idx": 394, "target": 0, "func": "public Connection connect( String url, Properties info, int loginTimeoutSeconds )\n\t\t throws SQLException \n\t{\n\t\tif (!acceptsURL(url)) { return null; }\n\t\t\n        /**\n         * If we are below the low memory watermark for obtaining\n         * a connection, then don't even try. Just throw an exception.\n         */\n\t\tif (EmbedConnection.memoryState.isLowMemory())\n\t\t{\n\t\t\tthrow EmbedConnection.NO_MEM;\n\t\t}\n        \t\t\t\n\t\t/*\n\t\t** A url \"jdbc:default:connection\" means get the current\n\t\t** connection.  From within a method called from JSQL, the\n\t\t** \"current\" connection is the one that is running the\n\t\t** JSQL statement containing the method call.\n\t\t*/\n\t\tboolean current = url.equals(Attribute.SQLJ_NESTED);\n\t\t\n\t\t/* If jdbc:default:connection, see if user already has a\n\t\t * connection. All connection attributes are ignored.\n\t\t */\n\t\tif (current) {\n\n\t\t\tConnectionContext connContext = getConnectionContext();\n\n\t\t\tif (connContext != null) {\n\t\t\t\t\t\t\n\t\t\t\treturn connContext.getNestedConnection(false);\n\t\t\t\t\n\t\t\t}\n\t\t\t// there is no Derby connection, so\n\t\t\t// return null, as we are not the driver to handle this\n\t\t\treturn null;\n\t\t}\n\n\t\t// convert the ;name=value attributes in the URL into\n\t\t// properties.\n\t\tFormatableProperties finfo = null;\n        \n\t\ttry {\n            \n            finfo = getAttributes(url, info);\n            info = null; // ensure we don't use this reference directly again.\n\n\t\t\t/*\n\t\t\t** A property \"shutdown=true\" means shut the system or database down\n\t\t\t*/\n\t\t\tboolean shutdown = Boolean.valueOf(finfo.getProperty(Attribute.SHUTDOWN_ATTR)).booleanValue();\n\t\t\t\n\t\t\tif (shutdown) {\t\t\t\t\n\t\t\t\t// If we are shutting down the system don't attempt to create\n\t\t\t\t// a connection; but we validate users credentials if we have to.\n\t\t\t\t// In case of datbase shutdown, we ask the database authentication\n\t\t\t\t// service to authenticate the user. If it is a system shutdown,\n\t\t\t\t// then we ask the Driver to do the authentication.\n\t\t\t\t//\n\t\t\t\tif (InternalDriver.getDatabaseName(url, finfo).length() == 0) {\n\t\t\t\t\t//\n\t\t\t\t\t// We need to authenticate the user if authentication is\n\t\t\t\t\t// ON. Note that this is a system shutdown.\n\t\t\t\t\t// check that we do have a authentication service\n\t\t\t\t\t// it is _always_ expected.\n\t\t\t\t\tif (this.getAuthenticationService() == null)\n\t\t\t\t\t\tthrow Util.generateCsSQLException(\n                        SQLState.LOGIN_FAILED, \n\t\t\t\t\t\tMessageService.getTextMessage(MessageId.AUTH_NO_SERVICE_FOR_SYSTEM));\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\tif (!this.getAuthenticationService().authenticate((String) null, finfo)) {\n\n\t\t\t\t\t\t// not a valid user\n\t\t\t\t\t\tthrow Util.generateCsSQLException(\n                                    SQLState.NET_CONNECT_AUTH_FAILED,\n                                    MessageService.\n                                    getTextMessage(MessageId.AUTH_INVALID));\n\t\t\t\t\t}\n\n                    // DERBY-2905, allow users to provide deregister attribute to \n                    // leave AutoloadedDriver registered in DriverManager, default\n                    // value is true\n                    if (finfo.getProperty(Attribute.DEREGISTER_ATTR) != null) {\n                        boolean deregister = Boolean.valueOf(\n                                finfo.getProperty(Attribute.DEREGISTER_ATTR))\n                                .booleanValue();\n                        InternalDriver.setDeregister(deregister);\n                    }\n\n\t\t\t\t\t// check for shutdown privileges\n\t\t\t\t\t// DERBY-3495: uncomment to enable system privileges checks\n\t\t\t\t\t//final String user = IdUtil.getUserNameFromURLProps(finfo);\n\t\t\t\t\t//checkShutdownPrivileges(user);\n\n\t\t\t\t\tMonitor.getMonitor().shutdown();\n\n\t\t\t\t\tthrow Util.generateCsSQLException(\n                                         SQLState.CLOUDSCAPE_SYSTEM_SHUTDOWN);\n\t\t\t\t}\n\t\t\t}\n\n            EmbedConnection conn;\n\t\t\t\n            if ( loginTimeoutSeconds <= 0 ) { conn = getNewEmbedConnection( url, finfo ); }\n            else { conn = timeLogin( url, finfo, loginTimeoutSeconds ); }\n            \n\t\t\t// if this is not the correct driver a EmbedConnection\n\t\t\t// object is returned in the closed state.\n\t\t\tif (conn.isClosed()) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn conn;\n\t\t}\n\t\tcatch (OutOfMemoryError noMemory)\n\t\t{\n\t\t\tEmbedConnection.memoryState.setLowMemory();\n\t\t\tthrow EmbedConnection.NO_MEM;\n\t\t}\n\t\tfinally {\n\t\t\t// break any link with the user's Properties set.\n            if (finfo != null)\n\t\t\t    finfo.clearDefaults();\n\t\t}\n\t}"}
{"idx": 395, "target": 0, "func": "protected FormatableProperties getAttributes(String url, Properties info) \n\t\tthrows SQLException {\n\n\t\t// We use FormatableProperties here to take advantage\n\t\t// of the clearDefaults, method.\n\t\tFormatableProperties finfo = new FormatableProperties(info);\n\t\tinfo = null; // ensure we don't use this reference directly again.\n\n\n\t\tStringTokenizer st = new StringTokenizer(url, \";\");\n\t\tst.nextToken(); // skip the first part of the url\n\n\t\twhile (st.hasMoreTokens()) {\n\n\t\t\tString v = st.nextToken();\n\n\t\t\tint eqPos = v.indexOf('=');\n\t\t\tif (eqPos == -1)\n\t\t\t\tthrow Util.generateCsSQLException(\n                                            SQLState.MALFORMED_URL, url);\n\n\t\t\t//if (eqPos != v.lastIndexOf('='))\n\t\t\t//\tthrow Util.malformedURL(url);\n\n\t\t\tfinfo.put((v.substring(0, eqPos)).trim(),\n\t\t\t\t\t (v.substring(eqPos + 1)).trim()\n\t\t\t\t\t);\n\t\t}\n\n\t\t// now validate any attributes we can\n\t\t//\n\t\t// Boolean attributes -\n\t\t//  dataEncryption,create,createSource,convertToSource,shutdown,upgrade,current\n\n\n\t\tcheckBoolean(finfo, Attribute.DATA_ENCRYPTION);\n\t\tcheckBoolean(finfo, Attribute.CREATE_ATTR);\n\t\tcheckBoolean(finfo, Attribute.SHUTDOWN_ATTR);\n        checkBoolean(finfo, Attribute.DEREGISTER_ATTR);\n\t\tcheckBoolean(finfo, Attribute.UPGRADE_ATTR);\n\n\t\treturn finfo;\n\t}"}
{"idx": 396, "target": 0, "func": "public DriverPropertyInfo[] getPropertyInfo(String url, Properties info)\n            throws SQLException {\n\n        // RESOLVE other properties should be added into this method in the future ...\n\n        if (info != null) {\n            if (Boolean.valueOf(info.getProperty(Attribute.SHUTDOWN_ATTR)).booleanValue()) {\n\n                // no other options possible when shutdown is set to be true\n                return new DriverPropertyInfo[0];\n            }\n        }\n\n        // at this point we have databaseName,\n\n        String dbname = InternalDriver.getDatabaseName(url, info);\n\n        // convert the ;name=value attributes in the URL into\n        // properties.\n        FormatableProperties finfo = getAttributes(url, info);\n        info = null; // ensure we don't use this reference directly again.\n        boolean encryptDB = Boolean.valueOf(finfo.getProperty(Attribute.DATA_ENCRYPTION)).booleanValue();\n        String encryptpassword = finfo.getProperty(Attribute.BOOT_PASSWORD);\n\n        if (dbname.length() == 0 || (encryptDB && encryptpassword == null)) {\n\n            // with no database name we can have shutdown or a database name\n\n            // In future, if any new attribute info needs to be included in this\n            // method, it just has to be added to either string or boolean or secret array\n            // depending on whether it accepts string or boolean or secret(ie passwords) value.\n\n            String[][] connStringAttributes = {\n                {Attribute.DBNAME_ATTR, MessageId.CONN_DATABASE_IDENTITY},\n                {Attribute.CRYPTO_PROVIDER, MessageId.CONN_CRYPTO_PROVIDER},\n                {Attribute.CRYPTO_ALGORITHM, MessageId.CONN_CRYPTO_ALGORITHM},\n                {Attribute.CRYPTO_KEY_LENGTH, MessageId.CONN_CRYPTO_KEY_LENGTH},\n                {Attribute.CRYPTO_EXTERNAL_KEY, MessageId.CONN_CRYPTO_EXTERNAL_KEY},\n                {Attribute.TERRITORY, MessageId.CONN_LOCALE},\n                {Attribute.COLLATION, MessageId.CONN_COLLATION},\n                {Attribute.USERNAME_ATTR, MessageId.CONN_USERNAME_ATTR},\n                {Attribute.LOG_DEVICE, MessageId.CONN_LOG_DEVICE},\n                {Attribute.ROLL_FORWARD_RECOVERY_FROM, MessageId.CONN_ROLL_FORWARD_RECOVERY_FROM},\n                {Attribute.CREATE_FROM, MessageId.CONN_CREATE_FROM},\n                {Attribute.RESTORE_FROM, MessageId.CONN_RESTORE_FROM},\n            };\n\n            String[][] connBooleanAttributes = {\n                {Attribute.SHUTDOWN_ATTR, MessageId.CONN_SHUT_DOWN_CLOUDSCAPE},\n                {Attribute.DEREGISTER_ATTR, MessageId.CONN_DEREGISTER_AUTOLOADEDDRIVER},\n                {Attribute.CREATE_ATTR, MessageId.CONN_CREATE_DATABASE},\n                {Attribute.DATA_ENCRYPTION, MessageId.CONN_DATA_ENCRYPTION},\n                {Attribute.UPGRADE_ATTR, MessageId.CONN_UPGRADE_DATABASE},\n                };\n\n            String[][] connStringSecretAttributes = {\n                {Attribute.BOOT_PASSWORD, MessageId.CONN_BOOT_PASSWORD},\n                {Attribute.PASSWORD_ATTR, MessageId.CONN_PASSWORD_ATTR},\n                };\n\n\n            DriverPropertyInfo[] optionsNoDB = new  DriverPropertyInfo[connStringAttributes.length+\n                                                                      connBooleanAttributes.length+\n                                                                      connStringSecretAttributes.length];\n\n            int attrIndex = 0;\n            for( int i = 0; i < connStringAttributes.length; i++, attrIndex++ )\n            {\n                optionsNoDB[attrIndex] = new DriverPropertyInfo(connStringAttributes[i][0],\n                                      finfo.getProperty(connStringAttributes[i][0]));\n                optionsNoDB[attrIndex].description = MessageService.getTextMessage(connStringAttributes[i][1]);\n            }\n\n            optionsNoDB[0].choices = Monitor.getMonitor().getServiceList(Property.DATABASE_MODULE);\n            // since database name is not stored in FormatableProperties, we\n            // assign here explicitly\n            optionsNoDB[0].value = dbname;\n\n            for( int i = 0; i < connStringSecretAttributes.length; i++, attrIndex++ )\n            {\n                optionsNoDB[attrIndex] = new DriverPropertyInfo(connStringSecretAttributes[i][0],\n                                      (finfo.getProperty(connStringSecretAttributes[i][0]) == null? \"\" : \"****\"));\n                optionsNoDB[attrIndex].description = MessageService.getTextMessage(connStringSecretAttributes[i][1]);\n            }\n\n            for( int i = 0; i < connBooleanAttributes.length; i++, attrIndex++ )\n            {\n                optionsNoDB[attrIndex] = new DriverPropertyInfo(connBooleanAttributes[i][0],\n                    Boolean.valueOf(finfo == null? \"\" : finfo.getProperty(connBooleanAttributes[i][0])).toString());\n                optionsNoDB[attrIndex].description = MessageService.getTextMessage(connBooleanAttributes[i][1]);\n                optionsNoDB[attrIndex].choices = BOOLEAN_CHOICES;\n            }\n\n            return optionsNoDB;\n        }\n\n        return new DriverPropertyInfo[0];\n    }"}
{"idx": 397, "target": 0, "func": "public Object run() {\n                File delFile = new File(fileName);\n                if (!delFile.exists())\n                    return null;\n                delFile.delete();\n                return null;\n            }"}
{"idx": 398, "target": 0, "func": "public  void    execute()\n        throws BuildException\n    {\n        File                 target = new File( _releasePropertiesFileName );\n        FileWriter      propertiesFW = null;\n        PrintWriter    propertiesPW = null;\n\n        try {\n            VersionID versionID = new VersionID( _releaseID );\n            if ( _bump ) { versionID.bump(); }\n            \n            int major = versionID.getMajor();\n            int minor = versionID.getMinor();\n            int currentYear = getCurrentYear();\n\n            propertiesFW = new FileWriter( target );\n            propertiesPW = new PrintWriter( propertiesFW );\n\n            propertiesPW.println( APACHE_LICENSE_HEADER );\n\n            propertiesPW.println( \"drdamaint=0\" );\n            propertiesPW.println( \"maint=\" + encodeFixpackAndPoint( versionID ) );\n            propertiesPW.println( \"major=\" + major );\n            propertiesPW.println( \"minor=\" + minor );\n            propertiesPW.println( \"eversion=\" + versionID.getBranchName() );\n            propertiesPW.println( \"beta=\" + versionID.isBeta() );\n            propertiesPW.println( \"copyright.comment=Copyright 1997, \" + currentYear + \" The Apache Software Foundation or its licensors, as applicable.\" );\n            propertiesPW.println( \"vendor=The Apache Software Foundation\" ) ;\n            propertiesPW.println( \"copyright.year=\" + currentYear ) ;\n            propertiesPW.println( \"release.id.long=\" + versionID.toString() ) ;\n\n            setProperty( NEW_RELEASE_ID, versionID.toString() );\n        }\n        catch (Exception e)\n        {\n            throw new BuildException( \"Could not generate release properties: \" + e.getMessage(), e );\n        }\n        finally\n        {\n            try {\n                finishWriting( propertiesFW, propertiesPW );\n            }\n            catch (Exception ex)\n            {\n                throw new BuildException( \"Error closing file writers.\", ex );\n            }\n        }\n    }"}
{"idx": 399, "target": 1, "func": "private HeaderManager createHeaderManager() {\n        HeaderManager manager = new HeaderManager();\n        for (String key : headers.keySet()) {\n            if (!key.equals(PROXY_CONNECTION)\n             && !key.equals(CONTENT_LENGTH)\n             && !key.equalsIgnoreCase(HTTPConstants.HEADER_CONNECTION)) {\n                manager.add(headers.get(key));\n            }\n        }\n        manager.setName(JMeterUtils.getResString(\"header_manager_title\")); // $NON-NLS-1$\n        manager.setProperty(TestElement.TEST_CLASS, HeaderManager.class.getName());\n        manager.setProperty(TestElement.GUI_CLASS, HeaderPanel.class.getName());\n        return manager;\n    }"}
{"idx": 400, "target": 1, "func": "private void initJMeterKeyStore() throws IOException, GeneralSecurityException {\n        if (storePassword  != null) { // Assume we have already created the store\n            try {\n                keyStore = getKeyStore(storePassword.toCharArray());\n                X509Certificate  caCert = (X509Certificate) keyStore.getCertificate(JMETER_SERVER_ALIAS);\n                caCert.checkValidity(new Date(System.currentTimeMillis()+DateUtils.MILLIS_PER_DAY));\n            } catch (Exception e) { // store is faulty, we need to recreate it\n                keyStore = null; // if cert is not valid, flag up to recreate it\n                log.warn(\"Could not open expected file or certificate is not valid \" + CERT_PATH_ABS  + \" \" + e.getMessage());\n            }\n        }\n        if (keyStore == null) { // no existing file or not valid\n            storePassword = RandomStringUtils.randomAlphanumeric(20); // Alphanum to avoid issues with command-line quoting\n            keyPassword = storePassword; // we use same password for both\n            setPassword(storePassword);\n            log.info(\"Generating standard keypair in \" + CERT_PATH_ABS);\n            CERT_PATH.delete(); // safer to start afresh\n            KeyToolUtils.genkeypair(CERT_PATH, JMETER_SERVER_ALIAS, storePassword, CERT_VALIDITY, null, null);\n            keyStore = getKeyStore(storePassword.toCharArray()); // This should now work\n        }\n    }"}
{"idx": 401, "target": 0, "func": "public synchronized void deliverSampler(final HTTPSamplerBase sampler, final TestElement[] subConfigs, final SampleResult result) {\n        if (sampler != null) {\n            if (ATTEMPT_REDIRECT_DISABLING && (samplerRedirectAutomatically || samplerFollowRedirects)) {\n                if (result instanceof HTTPSampleResult) {\n                    final HTTPSampleResult httpSampleResult = (HTTPSampleResult) result;\n                    final String urlAsString = httpSampleResult.getUrlAsString();\n                    if (urlAsString.equals(LAST_REDIRECT)) { // the url matches the last redirect\n                        sampler.setEnabled(false);\n                        sampler.setComment(\"Detected a redirect from the previous sample\");\n                    } else { // this is not the result of a redirect\n                        LAST_REDIRECT = null; // so break the chain\n                    }\n                    if (httpSampleResult.isRedirect()) { // Save Location so resulting sample can be disabled\n                        if (LAST_REDIRECT == null) {\n                            sampler.setComment(\"Detected the start of a redirect chain\");\n                        }\n                        LAST_REDIRECT = httpSampleResult.getRedirectLocation();\n                    } else {\n                        LAST_REDIRECT = null;\n                    }\n                }\n            }\n            if (filterContentType(result) && filterUrl(sampler)) {\n                JMeterTreeNode myTarget = findTargetControllerNode();\n                @SuppressWarnings(\"unchecked\") // OK, because find only returns correct element types\n                Collection<ConfigTestElement> defaultConfigurations = (Collection<ConfigTestElement>) findApplicableElements(myTarget, ConfigTestElement.class, false);\n                @SuppressWarnings(\"unchecked\") // OK, because find only returns correct element types\n                Collection<Arguments> userDefinedVariables = (Collection<Arguments>) findApplicableElements(myTarget, Arguments.class, true);\n\n                removeValuesFromSampler(sampler, defaultConfigurations);\n                replaceValues(sampler, subConfigs, userDefinedVariables);\n                sampler.setAutoRedirects(samplerRedirectAutomatically);\n                sampler.setFollowRedirects(samplerFollowRedirects);\n                sampler.setUseKeepAlive(useKeepAlive);\n                sampler.setImageParser(samplerDownloadImages);\n\n                placeSampler(sampler, subConfigs, myTarget);\n            } else {\n                if(log.isDebugEnabled()) {\n                    log.debug(\"Sample excluded based on url or content-type: \" + result.getUrlAsString() + \" - \" + result.getContentType());\n                }\n                result.setSampleLabel(\"[\"+result.getSampleLabel()+\"]\");\n            }\n        }\n        // SampleEvent is not passed JMeterVariables, because they don't make sense for Proxy Recording\n        notifySampleListeners(new SampleEvent(result, \"WorkBench\")); // TODO - is this the correct threadgroup name?\n    }"}
{"idx": 402, "target": 1, "func": "@Override\n    public Message sendAndReceive(Message request) throws JMSException {\n        String id = request.getJMSCorrelationID();\n        if(id == null && !useReqMsgIdAsCorrelId){\n            throw new IllegalArgumentException(\"Correlation id is null. Set the JMSCorrelationID header.\");\n        }\n        final CountDownLatch countDownLatch = new CountDownLatch(1);\n        final MessageAdmin admin = MessageAdmin.getAdmin();\n        if(useReqMsgIdAsCorrelId) {// msgId not available until after send() is called\n            // Note: there is only one admin object which is shared between all threads\n            synchronized (admin) {// interlock with Receiver\n                producer.send(request);\n                id=request.getJMSMessageID();\n                admin.putRequest(id, request, countDownLatch);\n            }\n        } else {\n            admin.putRequest(id, request, countDownLatch);            \n            producer.send(request);\n        }\n\n        try {\n            if (log.isDebugEnabled()) {\n                log.debug(Thread.currentThread().getName()+\" will wait for reply \" + id + \" started on \" + System.currentTimeMillis());\n            }\n            // This used to be request.wait(timeout_ms), where 0 means forever\n            // However 0 means return immediately for the latch\n            if (timeout == 0){\n                countDownLatch.await(); //\n            } else {\n                countDownLatch.await(timeout, TimeUnit.MILLISECONDS);\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(Thread.currentThread().getName()+\" done waiting for \" + id + \" on \"+request+\" ended on \" + System.currentTimeMillis());\n            }\n\n        } catch (InterruptedException e) {\n            log.warn(\"Interrupt exception caught\", e);\n        }\n        return admin.get(id);\n    }"}
{"idx": 403, "target": 0, "func": "public File getRandomFile(String basedir, String[] extensions) {\n        File input = null;\n        if (basedir != null) {\n            File src = new File(basedir);\n            if (src.isDirectory() && src.list() != null) {\n                File[] lfiles = src.listFiles(new JMeterFileFilter(extensions));\n                int count = lfiles.length;\n                input = lfiles[random.nextInt(count)];\n            }\n        }\n        return input;\n    }"}
{"idx": 404, "target": 1, "func": "@Override\n        public boolean equals(Object other) {\n            if (this == other) {\n                return true;\n            }\n            if (other instanceof UniqueObject) {\n                return propKey.equals(((UniqueObject) other).propKey);\n            }\n            return false;\n        }"}
{"idx": 405, "target": 1, "func": "public static int getPropDefault(String propName, int defaultVal) {\n        int ans;\n        try {\n            ans = (Integer.valueOf(appProperties.getProperty(propName, Integer.toString(defaultVal)).trim()))\n                    .intValue();\n        } catch (Exception e) {\n            ans = defaultVal;\n        }\n        return ans;\n    }"}
{"idx": 406, "target": 0, "func": "public static String getResourceFileAsText(String name) {\n        BufferedReader fileReader = null;\n        try {\n            String lineEnd = System.getProperty(\"line.separator\"); // $NON-NLS-1$\n            InputStream is = JMeterUtils.class.getClassLoader().getResourceAsStream(name);\n            if(is != null) {\n                fileReader = new BufferedReader(new InputStreamReader(is));\n                StringBuilder text = new StringBuilder();\n                String line = \"NOTNULL\"; // $NON-NLS-1$\n                while (line != null) {\n                    line = fileReader.readLine();\n                    if (line != null) {\n                        text.append(line);\n                        text.append(lineEnd);\n                    }\n                }\n                // Done by finally block: fileReader.close();\n                return text.toString();\n            } else {\n                return \"\"; // $NON-NLS-1$                \n            }\n        } catch (IOException e) {\n            return \"\"; // $NON-NLS-1$\n        } finally {\n            IOUtils.closeQuietly(fileReader);\n        }\n    }"}
{"idx": 407, "target": 0, "func": "public static final void helpGC() {\n        System.gc();\n        System.runFinalization();\n    }"}
{"idx": 408, "target": 1, "func": "private static void findClassesInPathsDir(String strPathElement, File dir, Set<String> listClasses) throws IOException {\n        String[] list = dir.list();\n        for (int i = 0; i < list.length; i++) {\n            File file = new File(dir, list[i]);\n            if (file.isDirectory()) {\n                // Recursive call\n                findClassesInPathsDir(strPathElement, file, listClasses);\n            } else if (list[i].endsWith(DOT_CLASS) && file.exists() && (file.length() != 0)) {\n                final String path = file.getPath();\n                listClasses.add(path.substring(strPathElement.length() + 1,\n                        path.lastIndexOf('.')) // $NON-NLS-1$\n                        .replace(File.separator.charAt(0), '.')); // $NON-NLS-1$\n            }\n        }\n    }"}
{"idx": 409, "target": 0, "func": "@Deprecated\n    public boolean checkMethod(Object _invokee){\n        Method m = null;\n        try {\n            m = doCreateMethod(_invokee.getClass(), getTypes(args));\n        } catch (Exception e){\n            // ignored\n        }\n        return null != m;\n    }"}
{"idx": 410, "target": 0, "func": "private boolean loadFromObj(File serialObj) {\n    try {\n      loadFromObjectInputStream(new FileInputStream(serialObj));\n      return true;\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }"}
{"idx": 411, "target": 1, "func": "synchronized int addOrGet(String fieldName, int preferredFieldNumber, DocValuesType dvType) {\n      if (dvType != null) {\n        DocValuesType currentDVType = docValuesType.get(fieldName);\n        if (currentDVType == null) {\n          docValuesType.put(fieldName, dvType);\n        } else if (currentDVType != null && currentDVType != dvType) {\n          throw new IllegalArgumentException(\"cannot change DocValues type from \" + currentDVType + \" to \" + dvType + \" for field \\\"\" + fieldName + \"\\\"\");\n        }\n      }\n      Integer fieldNumber = nameToNumber.get(fieldName);\n      if (fieldNumber == null) {\n        final Integer preferredBoxed = Integer.valueOf(preferredFieldNumber);\n\n        if (preferredFieldNumber != -1 && !numberToName.containsKey(preferredBoxed)) {\n          // cool - we can use this number globally\n          fieldNumber = preferredBoxed;\n        } else {\n          // find a new FieldNumber\n          while (numberToName.containsKey(++lowestUnassignedFieldNumber)) {\n            // might not be up to date - lets do the work once needed\n          }\n          fieldNumber = lowestUnassignedFieldNumber;\n        }\n        \n        numberToName.put(fieldNumber, fieldName);\n        nameToNumber.put(fieldName, fieldNumber);\n      }\n\n      return fieldNumber.intValue();\n    }"}
{"idx": 412, "target": 0, "func": "@SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    //System.out.println(\"FTE.next doSeek=\" + doSeek);\n    //new Throwable().printStackTrace(System.out);\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        //System.out.println(\"  seek to t=\" + (t == null ? \"null\" : t.utf8ToString()) + \" tenum=\" + tenum);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || t.compareTo(actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seekCeil(t) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          //System.out.println(\"  return null\");\n          return null;\n        }\n        actualTerm = tenum.term();\n        //System.out.println(\"  got term=\" + actualTerm.utf8ToString());\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }"}
{"idx": 413, "target": 1, "func": "@Override\n    public void collect(int doc) throws IOException {\n      fromDocTerms.get(doc, spare);\n      int ord = collectedTerms.add(spare);\n      if (ord < 0) {\n        ord = -ord - 1;\n      } else {\n        if (ord >= scoreSums.length) {\n          scoreSums = ArrayUtil.grow(scoreSums);\n        }\n      }\n\n      float current = scorer.score();\n      float existing = scoreSums[ord];\n      if (Float.compare(existing, 0.0f) == 0) {\n        scoreSums[ord] = current;\n      } else {\n        switch (scoreMode) {\n          case Total:\n            scoreSums[ord] = scoreSums[ord] + current;\n            break;\n          case Max:\n            if (current > existing) {\n              scoreSums[ord] = current;\n            }\n        }\n      }\n    }"}
{"idx": 414, "target": 0, "func": "public int[] getMatchEnds() {\n    return matchEnds;\n  }"}
{"idx": 415, "target": 0, "func": "public BytesRef[] getMatchTerms() {\n    return matchTerms;\n  }"}
{"idx": 416, "target": 1, "func": "@Override\n  public SpanFirstQuery clone() {\n    SpanFirstQuery spanFirstQuery = new SpanFirstQuery((SpanQuery) match.clone(), end);\n    spanFirstQuery.setBoost(getBoost());\n    return spanFirstQuery;\n  }"}
{"idx": 417, "target": 1, "func": "@Override\n  public void close() throws IOException {\n    try {\n      closeWriter();\n    } finally {\n      if (input != null) input.delete();\n      if (sorted != null) sorted.delete();\n    }\n  }"}
{"idx": 418, "target": 0, "func": "@Override\n    public int compareTo(Completion o) {\n      return this.utf8.compareTo(o.utf8);\n    }"}
{"idx": 419, "target": 0, "func": "@Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    BytesRef scratch = new BytesRef();\n    InputIterator iter = new WFSTInputIterator(iterator);\n    IntsRef scratchInts = new IntsRef();\n    BytesRef previous = null;\n    PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n    while ((scratch = iter.next()) != null) {\n      long cost = iter.weight();\n      \n      if (previous == null) {\n        previous = new BytesRef();\n      } else if (scratch.equals(previous)) {\n        continue; // for duplicate suggestions, the best weight is actually\n                  // added\n      }\n      Util.toIntsRef(scratch, scratchInts);\n      builder.add(scratchInts, cost);\n      previous.copyBytes(scratch);\n    }\n    fst = builder.finish();\n  }"}
{"idx": 420, "target": 0, "func": "@Override\n  protected Directory create(String path, DirContext dirContext)\n      throws IOException {\n    LOG.info(\"creating directory factory for path {}\", path);\n    Configuration conf = getConf();\n    \n    if (metrics == null) {\n      metrics = new Metrics(conf);\n    }\n    \n    boolean blockCacheEnabled = params.getBool(BLOCKCACHE_ENABLED, true);\n    boolean blockCacheReadEnabled = params.getBool(BLOCKCACHE_READ_ENABLED,\n        true);\n    boolean blockCacheWriteEnabled = params.getBool(BLOCKCACHE_WRITE_ENABLED, true);\n    Directory dir = null;\n    \n    if (blockCacheEnabled && dirContext != DirContext.META_DATA) {\n      int numberOfBlocksPerBank = params.getInt(NUMBEROFBLOCKSPERBANK, 16384);\n      \n      int blockSize = BlockDirectory.BLOCK_SIZE;\n      \n      int bankCount = params.getInt(BLOCKCACHE_SLAB_COUNT, 1);\n      \n      boolean directAllocation = params.getBool(\n          BLOCKCACHE_DIRECT_MEMORY_ALLOCATION, true);\n      \n      BlockCache blockCache;\n      \n      int slabSize = numberOfBlocksPerBank * blockSize;\n      LOG.info(\n          \"Number of slabs of block cache [{}] with direct memory allocation set to [{}]\",\n          bankCount, directAllocation);\n      LOG.info(\n          \"Block cache target memory usage, slab size of [{}] will allocate [{}] slabs and use ~[{}] bytes\",\n          new Object[] {slabSize, bankCount,\n              ((long) bankCount * (long) slabSize)});\n      \n      int _1024Size = params.getInt(\"solr.hdfs.blockcache.bufferstore.1024\",\n          8192);\n      int _8192Size = params.getInt(\"solr.hdfs.blockcache.bufferstore.8192\",\n          8192);\n      \n      BufferStore.init(_1024Size, _8192Size, metrics);\n      long totalMemory = (long) bankCount * (long) numberOfBlocksPerBank\n          * (long) blockSize;\n      try {\n        blockCache = new BlockCache(metrics, directAllocation, totalMemory,\n            slabSize, blockSize);\n      } catch (OutOfMemoryError e) {\n        throw new RuntimeException(\n            \"The max direct memory is likely too low.  Either increase it (by adding -XX:MaxDirectMemorySize=<size>g -XX:+UseLargePages to your containers startup args)\"\n                + \" or disable direct allocation using solr.hdfs.blockcache.direct.memory.allocation=false in solrconfig.xml. If you are putting the block cache on the heap,\"\n                + \" your java heap size might not be large enough.\"\n                + \" Failed allocating ~\" + totalMemory / 1000000.0 + \" MB.\", e);\n      }\n      Cache cache = new BlockDirectoryCache(blockCache, metrics);\n      HdfsDirectory hdfsDirectory = new HdfsDirectory(new Path(path), conf);\n      dir = new BlockDirectory(\"solrcore\", hdfsDirectory, cache, null,\n          blockCacheReadEnabled, blockCacheWriteEnabled);\n    } else {\n      dir = new HdfsDirectory(new Path(path), conf);\n    }\n    \n    boolean nrtCachingDirectory = params.getBool(NRTCACHINGDIRECTORY_ENABLE, true);\n    if (nrtCachingDirectory) {\n      double nrtCacheMaxMergeSizeMB = params.getInt(\n          NRTCACHINGDIRECTORY_MAXMERGESIZEMB, 16);\n      double nrtCacheMaxCacheMB = params.getInt(NRTCACHINGDIRECTORY_MAXCACHEMB,\n          192);\n      \n      return new NRTCachingDirectory(dir, nrtCacheMaxMergeSizeMB,\n          nrtCacheMaxCacheMB);\n    }\n    return dir;\n  }"}
{"idx": 421, "target": 1, "func": "@Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double [] point = new double[0];\n    try {\n      point = ParseUtils.parsePointDouble(null, options.pointStr, 2);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    String geohash = GeohashUtils.encodeLatLon(point[0], point[1]);\n    //TODO: optimize this\n    return new SolrConstantScoreQuery(new ValueSourceRangeFilter(new GeohashHaversineFunction(getValueSource(options.field, parser),\n            new LiteralValueSource(geohash), options.radius), \"0\", String.valueOf(options.distance), true, true));\n  }"}
{"idx": 422, "target": 1, "func": "private void add(String fl, NamedList<String> rename, DocTransformers augmenters, SolrQueryRequest req) {\n    if( fl == null ) {\n      return;\n    }\n    try {\n      QueryParsing.StrParser sp = new QueryParsing.StrParser(fl);\n\n      for(;;) {\n        sp.opt(',');\n        sp.eatws();\n        if (sp.pos >= sp.end) break;\n\n        int start = sp.pos;\n\n        // short circuit test for a really simple field name\n        String key = null;\n        String field = getFieldName(sp);\n        char ch = sp.ch();\n\n        if (field != null) {\n          if (sp.opt(':')) {\n            // this was a key, not a field name\n            key = field;\n            field = null;\n            sp.eatws();\n            start = sp.pos;\n          } else {\n            if (Character.isWhitespace(ch) || ch == ',' || ch==0) {\n              addField( field, key, augmenters, req );\n              continue;\n            }\n            // an invalid field name... reset the position pointer to retry\n            sp.pos = start;\n            field = null;\n          }\n        }\n\n        if (key != null) {\n          // we read \"key : \"\n          field = sp.getId(null);\n          ch = sp.ch();\n          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {\n            rename.add(field, key);\n            addField( field, key, augmenters, req );\n            continue;\n          }\n          // an invalid field name... reset the position pointer to retry\n          sp.pos = start;\n          field = null;\n        }\n\n        if (field == null) {\n          // We didn't find a simple name, so let's see if it's a globbed field name.\n          // Globbing only works with field names of the recommended form (roughly like java identifiers)\n\n          field = sp.getGlobbedId(null);\n          ch = sp.ch();\n          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {\n            // \"*\" looks and acts like a glob, but we give it special treatment\n            if (\"*\".equals(field)) {\n              _wantsAllFields = true;\n            } else {\n              globs.add(field);\n            }\n            continue;\n          }\n\n          // an invalid glob\n          sp.pos = start;\n        }\n\n        String funcStr = sp.val.substring(start);\n\n        // Is it an augmenter of the form [augmenter_name foo=1 bar=myfield]?\n        // This is identical to localParams syntax except it uses [] instead of {!}\n\n        if (funcStr.startsWith(\"[\")) {\n          Map<String,String> augmenterArgs = new HashMap<String,String>();\n          int end = QueryParsing.parseLocalParams(funcStr, 0, augmenterArgs, req.getParams(), \"[\", ']');\n          sp.pos += end;\n\n          // [foo] is short for [type=foo] in localParams syntax\n          String augmenterName = augmenterArgs.remove(\"type\");\n          String disp = key;\n          if( disp == null ) {\n            disp = '['+augmenterName+']';\n          }\n\n          TransformerFactory factory = req.getCore().getTransformerFactory( augmenterName );\n          if( factory != null ) {\n            MapSolrParams augmenterParams = new MapSolrParams( augmenterArgs );\n            augmenters.addTransformer( factory.create(disp, augmenterParams, req) );\n          }\n          else {\n            // unknown transformer?\n          }\n          addField(field, disp, augmenters, req);\n          continue;\n        }\n\n\n        // let's try it as a function instead\n        QParser parser = QParser.getParser(funcStr, FunctionQParserPlugin.NAME, req);\n        Query q = null;\n        ValueSource vs = null;\n\n        try {\n          if (parser instanceof FunctionQParser) {\n            FunctionQParser fparser = (FunctionQParser)parser;\n            fparser.setParseMultipleSources(false);\n            fparser.setParseToEnd(false);\n\n            q = fparser.getQuery();\n\n            if (fparser.localParams != null) {\n              if (fparser.valFollowedParams) {\n                // need to find the end of the function query via the string parser\n                int leftOver = fparser.sp.end - fparser.sp.pos;\n                sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover\n              } else {\n                // the value was via the \"v\" param in localParams, so we need to find\n                // the end of the local params themselves to pick up where we left off\n                sp.pos = start + fparser.localParamsEnd;\n              }\n            } else {\n              // need to find the end of the function query via the string parser\n              int leftOver = fparser.sp.end - fparser.sp.pos;\n              sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover\n            }\n          } else {\n            // A QParser that's not for function queries.\n            // It must have been specified via local params.\n            q = parser.getQuery();\n\n            assert parser.getLocalParams() != null;\n            sp.pos = start + parser.localParamsEnd;\n          }\n\n\n          if (q instanceof FunctionQuery) {\n            vs = ((FunctionQuery)q).getValueSource();\n          } else {\n            vs = new QueryValueSource(q, 0.0f);\n          }\n\n          if (key==null) {\n            SolrParams localParams = parser.getLocalParams();\n            if (localParams != null) {\n              key = localParams.get(\"key\");\n            }\n            if (key == null) {\n              // use the function name itself as the field name\n              key = sp.val.substring(start, sp.pos);\n            }\n          }\n\n\n          if (key==null) {\n            key = funcStr;\n          }\n          okFieldNames.add( key );\n          okFieldNames.add( funcStr );\n          augmenters.addTransformer( new ValueSourceAugmenter( key, parser, vs ) );\n        }\n        catch (SyntaxError e) {\n          // try again, simple rules for a field name with no whitespace\n          sp.pos = start;\n          field = sp.getSimpleString();\n\n          if (req.getSchema().getFieldOrNull(field) != null) {\n            // OK, it was an oddly named field\n            fields.add(field);\n            if( key != null ) {\n              rename.add(field, key);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing fieldname: \" + e.getMessage(), e);\n          }\n        }\n\n        // end try as function\n\n      } // end for(;;)\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing fieldname\", e);\n    }\n  }"}
{"idx": 423, "target": 0, "func": "private void add(String fl, NamedList<String> rename, DocTransformers augmenters, SolrQueryRequest req) {\n    if( fl == null ) {\n      return;\n    }\n    try {\n      QueryParsing.StrParser sp = new QueryParsing.StrParser(fl);\n\n      for(;;) {\n        sp.opt(',');\n        sp.eatws();\n        if (sp.pos >= sp.end) break;\n\n        int start = sp.pos;\n\n        // short circuit test for a really simple field name\n        String key = null;\n        String field = getFieldName(sp);\n        char ch = sp.ch();\n\n        if (field != null) {\n          if (sp.opt(':')) {\n            // this was a key, not a field name\n            key = field;\n            field = null;\n            sp.eatws();\n            start = sp.pos;\n          } else {\n            if (Character.isWhitespace(ch) || ch == ',' || ch==0) {\n              addField( field, key, augmenters, req );\n              continue;\n            }\n            // an invalid field name... reset the position pointer to retry\n            sp.pos = start;\n            field = null;\n          }\n        }\n\n        if (key != null) {\n          // we read \"key : \"\n          field = sp.getId(null);\n          ch = sp.ch();\n          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {\n            rename.add(field, key);\n            addField( field, key, augmenters, req );\n            continue;\n          }\n          // an invalid field name... reset the position pointer to retry\n          sp.pos = start;\n          field = null;\n        }\n\n        if (field == null) {\n          // We didn't find a simple name, so let's see if it's a globbed field name.\n          // Globbing only works with field names of the recommended form (roughly like java identifiers)\n\n          field = sp.getGlobbedId(null);\n          ch = sp.ch();\n          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {\n            // \"*\" looks and acts like a glob, but we give it special treatment\n            if (\"*\".equals(field)) {\n              _wantsAllFields = true;\n            } else {\n              globs.add(field);\n            }\n            continue;\n          }\n\n          // an invalid glob\n          sp.pos = start;\n        }\n\n        String funcStr = sp.val.substring(start);\n\n        // Is it an augmenter of the form [augmenter_name foo=1 bar=myfield]?\n        // This is identical to localParams syntax except it uses [] instead of {!}\n\n        if (funcStr.startsWith(\"[\")) {\n          Map<String,String> augmenterArgs = new HashMap<String,String>();\n          int end = QueryParsing.parseLocalParams(funcStr, 0, augmenterArgs, req.getParams(), \"[\", ']');\n          sp.pos += end;\n\n          // [foo] is short for [type=foo] in localParams syntax\n          String augmenterName = augmenterArgs.remove(\"type\");\n          String disp = key;\n          if( disp == null ) {\n            disp = '['+augmenterName+']';\n          }\n\n          TransformerFactory factory = req.getCore().getTransformerFactory( augmenterName );\n          if( factory != null ) {\n            MapSolrParams augmenterParams = new MapSolrParams( augmenterArgs );\n            augmenters.addTransformer( factory.create(disp, augmenterParams, req) );\n          }\n          else {\n            // unknown transformer?\n          }\n          addField(field, disp, augmenters, req);\n          continue;\n        }\n\n\n        // let's try it as a function instead\n        QParser parser = QParser.getParser(funcStr, FunctionQParserPlugin.NAME, req);\n        Query q = null;\n        ValueSource vs = null;\n\n        try {\n          if (parser instanceof FunctionQParser) {\n            FunctionQParser fparser = (FunctionQParser)parser;\n            fparser.setParseMultipleSources(false);\n            fparser.setParseToEnd(false);\n\n            q = fparser.getQuery();\n\n            if (fparser.localParams != null) {\n              if (fparser.valFollowedParams) {\n                // need to find the end of the function query via the string parser\n                int leftOver = fparser.sp.end - fparser.sp.pos;\n                sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover\n              } else {\n                // the value was via the \"v\" param in localParams, so we need to find\n                // the end of the local params themselves to pick up where we left off\n                sp.pos = start + fparser.localParamsEnd;\n              }\n            } else {\n              // need to find the end of the function query via the string parser\n              int leftOver = fparser.sp.end - fparser.sp.pos;\n              sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover\n            }\n          } else {\n            // A QParser that's not for function queries.\n            // It must have been specified via local params.\n            q = parser.getQuery();\n\n            assert parser.getLocalParams() != null;\n            sp.pos = start + parser.localParamsEnd;\n          }\n\n\n          if (q instanceof FunctionQuery) {\n            vs = ((FunctionQuery)q).getValueSource();\n          } else {\n            vs = new QueryValueSource(q, 0.0f);\n          }\n\n          if (key==null) {\n            SolrParams localParams = parser.getLocalParams();\n            if (localParams != null) {\n              key = localParams.get(\"key\");\n            }\n            if (key == null) {\n              // use the function name itself as the field name\n              key = sp.val.substring(start, sp.pos);\n            }\n          }\n\n\n          if (key==null) {\n            key = funcStr;\n          }\n          okFieldNames.add( key );\n          okFieldNames.add( funcStr );\n          augmenters.addTransformer( new ValueSourceAugmenter( key, parser, vs ) );\n        }\n        catch (SyntaxError e) {\n          // try again, simple rules for a field name with no whitespace\n          sp.pos = start;\n          field = sp.getSimpleString();\n\n          if (req.getSchema().getFieldOrNull(field) != null) {\n            // OK, it was an oddly named field\n            fields.add(field);\n            if( key != null ) {\n              rename.add(field, key);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing fieldname: \" + e.getMessage(), e);\n          }\n        }\n\n        // end try as function\n\n      } // end for(;;)\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing fieldname\", e);\n    }\n  }"}
{"idx": 424, "target": 1, "func": "public Object evaluate( String expr )\n        throws ExpressionEvaluationException\n    {\n        return evaluate( expr, null );\n    }"}
{"idx": 425, "target": 0, "func": "protected Artifact createArtifact( String groupId, String artifactId, String version )\n        throws Exception\n    {\n        Dependency dependency = new Dependency();\n        dependency.setGroupId( groupId );\n        dependency.setArtifactId( artifactId );\n        dependency.setVersion( version );\n        dependency.setType( \"jar\" );\n        dependency.setScope( \"compile\" );\n\n        return factory.createDependencyArtifact( dependency );\n    }"}
{"idx": 426, "target": 0, "func": "protected Artifact createArtifact( String groupId, String artifactId, String version )\n        throws Exception\n    {\n        Dependency dependency = new Dependency();\n        dependency.setGroupId( groupId );\n        dependency.setArtifactId( artifactId );\n        dependency.setVersion( version );\n        dependency.setType( \"jar\" );\n        dependency.setScope( \"compile\" );\n\n        return factory.createDependencyArtifact( dependency );\n    }"}
{"idx": 427, "target": 1, "func": "@Override\n    protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {\n        if (Boolean.TRUE == req.getAttribute(\"dispatch\")) {\n            log.info(\"Received dispatch, completing on the worker thread.\");\n            log.info(\"After complete called started:\"+req.isAsyncStarted());\n            resp.getWriter().write(\"Async dispatch worked:+\"+System.currentTimeMillis()+\"\\n\");\n        } else {\n            resp.setContentType(\"text/plain\");\n            final AsyncContext actx = req.startAsync();\n            actx.setTimeout(Long.MAX_VALUE);\n            Runnable run = new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        req.setAttribute(\"dispatch\", Boolean.TRUE);\n                        Thread.currentThread().setName(\"Async0-Thread\");\n                        log.info(\"Putting AsyncThread to sleep\");\n                        Thread.sleep(2*1000);\n                        log.info(\"Dispatching\");\n                        actx.dispatch();\n                    }catch (InterruptedException x) {\n                        log.error(\"Async1\",x);\n                    }catch (IllegalStateException x) {\n                        log.error(\"Async1\",x);\n                    }\n                }\n            };\n            Thread t = new Thread(run);\n            t.start();\n        }\n    }"}
{"idx": 428, "target": 0, "func": "@Override\n    public Class<?> getType(ELContext context, Object base, Object property) {\n\n        if (context == null) {\n            throw new NullPointerException();\n        }\n        if (base != null || !(property instanceof String)) {\n            return null;\n        }\n\n        String beanName = (String) property;\n\n        try {\n            if (beanNameResolver.isNameResolved(beanName)) {\n                Class<?> result = beanNameResolver.getBean(beanName).getClass();\n                context.setPropertyResolved(base, property);\n                return result;\n            }\n        } catch (Throwable t) {\n            Util.handleThrowable(t);\n            throw new ELException(t);\n        }\n\n        return null;\n    }"}
{"idx": 429, "target": 0, "func": "@Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n\n        resp.setContentType(\"text/plain\");\n        resp.setCharacterEncoding(\"UTF-8\");\n\n        // Non-blocking IO requires async\n        AsyncContext ac = req.startAsync();\n\n        // Use a single listener for read and write. Listeners often need to\n        // share state to coordinate reads and writes and this is much easier as\n        // a single object.\n        @SuppressWarnings(\"unused\")\n        CounterListener listener = new CounterListener(\n                ac, req.getInputStream(), resp.getOutputStream());\n    }"}
{"idx": 430, "target": 0, "func": "@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n\n        resp.setContentType(\"text/plain\");\n        resp.setCharacterEncoding(\"UTF-8\");\n\n        // Non-blocking IO requires async\n        AsyncContext ac = req.startAsync();\n\n        // Use a single listener for read and write. Listeners often need to\n        // share state to coordinate reads and writes and this is much easier as\n        // a single object.\n        @SuppressWarnings(\"unused\")\n        NumberWriterListener listener = new NumberWriterListener(\n                ac, req.getInputStream(), resp.getOutputStream());\n\n    }"}
{"idx": 431, "target": 1, "func": "protected Object convertStringToType(String value, String valueType) {\n        if (\"java.lang.String\".equals(valueType))\n            return value;\n\n        Object convertValue = value;\n        if (\"java.lang.Integer\".equals(valueType) || \"int\".equals(valueType)) {\n            try {\n                convertValue = new Integer(value);\n            } catch (NumberFormatException ex) {\n                if (isEcho())\n                    handleErrorOutput(\"Unable to convert to integer:\" + value);\n            }\n        } else if (\"java.lang.Long\".equals(valueType)\n                || \"long\".equals(valueType)) {\n            try {\n                convertValue = new Long(value);\n            } catch (NumberFormatException ex) {\n                if (isEcho())\n                    handleErrorOutput(\"Unable to convert to long:\" + value);\n            }\n        } else if (\"java.lang.Boolean\".equals(valueType)\n                || \"boolean\".equals(valueType)) {\n            convertValue = Boolean.valueOf(value);\n        } else if (\"java.lang.Float\".equals(valueType)\n                || \"float\".equals(valueType)) {\n            try {\n                convertValue = new Float(value);\n            } catch (NumberFormatException ex) {\n                if (isEcho())\n                    handleErrorOutput(\"Unable to convert to float:\" + value);\n            }\n        } else if (\"java.lang.Double\".equals(valueType)\n                || \"double\".equals(valueType)) {\n            try {\n                convertValue = new Double(value);\n            } catch (NumberFormatException ex) {\n                if (isEcho())\n                    handleErrorOutput(\"Unable to convert to double:\" + value);\n            }\n        } else if (\"javax.management.ObjectName\".equals(valueType)\n                || \"name\".equals(valueType)) {\n            try {\n                convertValue = new ObjectName(value);\n            } catch (MalformedObjectNameException e) {\n                if (isEcho())\n                    handleErrorOutput(\"Unable to convert to ObjectName:\"\n                            + value);\n            }\n        } else if (\"java.net.InetAddress\".equals(valueType)) {\n            try {\n                convertValue = InetAddress.getByName(value);\n            } catch (UnknownHostException exc) {\n                if (isEcho())\n                    handleErrorOutput(\"Unable to resolve host name:\" + value);\n            }\n        }\n        return convertValue;\n    }"}
{"idx": 432, "target": 0, "func": "public boolean validate(Request request) {\n            if ( (userName == null) || (realmName == null) || (nonce == null)\n                 || (uri == null) || (response == null) ) {\n                return false;\n            }\n\n            // Validate the URI - should match the request line sent by client\n            if (validateUri) {\n                String uriQuery;\n                String query = request.getQueryString();\n                if (query == null) {\n                    uriQuery = request.getRequestURI();\n                } else {\n                    uriQuery = request.getRequestURI() + \"?\" + query;\n                }\n                if (!uri.equals(uriQuery)) {\n                    // Some clients (older Android) use an absolute URI for\n                    // DIGEST but a relative URI in the request line.\n                    // request. 2.3.5 < fixed Android version <= 4.0.3\n                    String host = request.getHeader(\"host\");\n                    String scheme = request.getScheme();\n                    if (host != null && !uriQuery.startsWith(scheme)) {\n                        StringBuilder absolute = new StringBuilder();\n                        absolute.append(scheme);\n                        absolute.append(\"://\");\n                        absolute.append(host);\n                        absolute.append(uriQuery);\n                        if (!uri.equals(absolute.toString())) {\n                            return false;\n                        }\n                    } else {\n                        return false;\n                    }\n                }\n            }\n\n            // Validate the Realm name\n            String lcRealm = getRealmName(request.getContext());\n            if (!lcRealm.equals(realmName)) {\n                return false;\n            }\n\n            // Validate the opaque string\n            if (!opaque.equals(opaqueReceived)) {\n                return false;\n            }\n\n            // Validate nonce\n            int i = nonce.indexOf(\":\");\n            if (i < 0 || (i + 1) == nonce.length()) {\n                return false;\n            }\n            long nonceTime;\n            try {\n                nonceTime = Long.parseLong(nonce.substring(0, i));\n            } catch (NumberFormatException nfe) {\n                return false;\n            }\n            String md5clientIpTimeKey = nonce.substring(i + 1);\n            long currentTime = System.currentTimeMillis();\n            if ((currentTime - nonceTime) > nonceValidity) {\n                nonceStale = true;\n                synchronized (nonces) {\n                    nonces.remove(nonce);\n                }\n            }\n            String serverIpTimeKey =\n                request.getRemoteAddr() + \":\" + nonceTime + \":\" + key;\n            byte[] buffer = ConcurrentMessageDigest.digestMD5(\n                    serverIpTimeKey.getBytes(StandardCharsets.ISO_8859_1));\n            String md5ServerIpTimeKey = MD5Encoder.encode(buffer);\n            if (!md5ServerIpTimeKey.equals(md5clientIpTimeKey)) {\n                return false;\n            }\n\n            // Validate qop\n            if (qop != null && !QOP.equals(qop)) {\n                return false;\n            }\n\n            // Validate cnonce and nc\n            // Check if presence of nc and Cnonce is consistent with presence of qop\n            if (qop == null) {\n                if (cnonce != null || nc != null) {\n                    return false;\n                }\n            } else {\n                if (cnonce == null || nc == null) {\n                    return false;\n                }\n                // RFC 2617 says nc must be 8 digits long. Older Android clients\n                // use 6. 2.3.5 < fixed Android version <= 4.0.3\n                if (nc.length() < 6 || nc.length() > 8) {\n                    return false;\n                }\n                long count;\n                try {\n                    count = Long.parseLong(nc, 16);\n                } catch (NumberFormatException nfe) {\n                    return false;\n                }\n                NonceInfo info;\n                synchronized (nonces) {\n                    info = nonces.get(nonce);\n                }\n                if (info == null) {\n                    // Nonce is valid but not in cache. It must have dropped out\n                    // of the cache - force a re-authentication\n                    nonceStale = true;\n                } else {\n                    if (!info.nonceCountValid(count)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }"}
{"idx": 433, "target": 0, "func": "public synchronized Session[] findSessions() {\n        return (this.sessions);\n    }"}
{"idx": 434, "target": 1, "func": "protected Session doGetSession(boolean create) {\n\n        // There cannot be a session if no context has been assigned yet\n        if (context == null) {\n            return (null);\n        }\n\n        // Return the current session if it exists and is valid\n        if ((session != null) && !session.isValid()) {\n            session = null;\n        }\n        if (session != null) {\n            return (session);\n        }\n\n        // Return the requested session if it exists and is valid\n        Manager manager = null;\n        if (context != null) {\n            manager = context.getManager();\n        }\n        if (manager == null)\n         {\n            return (null);      // Sessions are not supported\n        }\n        if (requestedSessionId != null) {\n            try {\n                session = manager.findSession(requestedSessionId);\n            } catch (IOException e) {\n                session = null;\n            }\n            if ((session != null) && !session.isValid()) {\n                session = null;\n            }\n            if (session != null) {\n                session.access();\n                return (session);\n            }\n        }\n\n        // Create a new session if requested and the response is not committed\n        if (!create) {\n            return (null);\n        }\n        if ((context != null) && (response != null) &&\n            context.getServletContext().getEffectiveSessionTrackingModes().\n                    contains(SessionTrackingMode.COOKIE) &&\n            response.getResponse().isCommitted()) {\n            throw new IllegalStateException\n              (sm.getString(\"coyoteRequest.sessionCreateCommitted\"));\n        }\n\n        // Attempt to reuse session id if one was submitted in a cookie\n        // Do not reuse the session id if it is from a URL, to prevent possible\n        // phishing attacks\n        // Use the SSL session ID if one is present.\n        if ((\"/\".equals(context.getSessionCookiePath())\n                && isRequestedSessionIdFromCookie()) || requestedSessionSSL ) {\n            session = manager.createSession(getRequestedSessionId());\n        } else {\n            session = manager.createSession(null);\n        }\n\n        // Creating a new session cookie based on that session\n        if ((session != null) && (getContext() != null)\n               && getContext().getServletContext().\n                       getEffectiveSessionTrackingModes().contains(\n                               SessionTrackingMode.COOKIE)) {\n            Cookie cookie =\n                ApplicationSessionCookieConfig.createSessionCookie(\n                        context, session.getIdInternal(), isSecure());\n\n            response.addSessionCookieInternal(cookie);\n        }\n\n        if (session == null) {\n            return null;\n        }\n\n        session.access();\n        return session;\n    }"}
{"idx": 435, "target": 0, "func": "@Override\n    public String getPathTranslated() {\n\n        if (context == null) {\n            return null;\n        }\n\n        if (getPathInfo() == null) {\n            return null;\n        }\n\n        return context.getServletContext().getRealPath(getPathInfo());\n    }"}
{"idx": 436, "target": 0, "func": "@Override\n    public void setCharacterEncoding(String enc)\n        throws UnsupportedEncodingException {\n\n        if (usingReader) {\n            return;\n        }\n\n        // Ensure that the specified encoding is valid\n        byte buffer[] = new byte[1];\n        buffer[0] = (byte) 'a';\n\n        // Confirm that the encoding name is valid\n        B2CConverter.getCharset(enc);\n\n        // Save the validated encoding\n        coyoteRequest.setCharacterEncoding(enc);\n    }"}
{"idx": 437, "target": 1, "func": "@Override\n    public String getParameter(String name) {\n\n        parseParameters();\n\n        Object value = parameters.get(name);\n        if (value == null)\n            return (null);\n        else if (value instanceof String[])\n            return (((String[]) value)[0]);\n        else if (value instanceof String)\n            return ((String) value);\n        else\n            return (value.toString());\n\n    }"}
{"idx": 438, "target": 1, "func": "@Override\n    public String[] getParameterValues(String name) {\n\n        parseParameters();\n        Object value = parameters.get(name);\n        if (value == null)\n            return null;\n        else if (value instanceof String[])\n            return ((String[]) value);\n        else if (value instanceof String) {\n            String values[] = new String[1];\n            values[0] = (String) value;\n            return (values);\n        } else {\n            String values[] = new String[1];\n            values[0] = value.toString();\n            return (values);\n        }\n\n    }"}
{"idx": 439, "target": 0, "func": "private void mergeParameters() {\n\n        if ((queryParamString == null) || (queryParamString.length() < 1))\n            return;\n\n        HashMap<String, String[]> queryParameters = new HashMap<>();\n        String encoding = getCharacterEncoding();\n        if (encoding == null)\n            encoding = \"ISO-8859-1\";\n        RequestUtil.parseParameters(queryParameters, queryParamString,\n                encoding);\n        Iterator<String> keys = parameters.keySet().iterator();\n        while (keys.hasNext()) {\n            String key = keys.next();\n            Object value = queryParameters.get(key);\n            if (value == null) {\n                queryParameters.put(key, parameters.get(key));\n                continue;\n            }\n            queryParameters.put\n                (key, mergeValues(value, parameters.get(key)));\n        }\n        parameters = queryParameters;\n\n    }"}
{"idx": 440, "target": 1, "func": "@Override\n    public Object[] getApplicationEventListeners() {\n        return (applicationEventListenersObjects);\n    }"}
{"idx": 441, "target": 0, "func": "@Override\n    public Object[] getApplicationLifecycleListeners() {\n        return (applicationLifecycleListenersObjects);\n    }"}
{"idx": 442, "target": 1, "func": "@Override\n    public void setApplicationEventListeners(Object listeners[]) {\n        applicationEventListenersObjects = listeners;\n    }"}
{"idx": 443, "target": 0, "func": "@Override\n    public void setApplicationLifecycleListeners(Object listeners[]) {\n        applicationLifecycleListenersObjects = listeners;\n    }"}
{"idx": 444, "target": 0, "func": "public String[] setJavaVMs(String[] javaVMs) {\n        return this.javaVMs = javaVMs;\n    }"}
{"idx": 445, "target": 1, "func": "public boolean filterStop() {\n\n        if (getLogger().isDebugEnabled())\n            getLogger().debug(\"Stopping filters\");\n\n        // Release all Filter and FilterConfig instances\n        synchronized (filterConfigs) {\n            Iterator<String> names = filterConfigs.keySet().iterator();\n            while (names.hasNext()) {\n                String name = names.next();\n                if (getLogger().isDebugEnabled())\n                    getLogger().debug(\" Stopping filter '\" + name + \"'\");\n                ApplicationFilterConfig filterConfig = filterConfigs.get(name);\n                filterConfig.release();\n            }\n            filterConfigs.clear();\n        }\n        return (true);\n\n    }"}
{"idx": 446, "target": 0, "func": "public String[] findReloadedContextMemoryLeaks() {\n\n        System.gc();\n\n        List<String> result = new ArrayList<>();\n\n        for (Map.Entry<ClassLoader, String> entry :\n                childClassLoaders.entrySet()) {\n            ClassLoader cl = entry.getKey();\n            if (cl instanceof WebappClassLoader) {\n                if (!((WebappClassLoader) cl).isStarted()) {\n                    result.add(entry.getValue());\n                }\n            }\n        }\n\n        return result.toArray(new String[result.size()]);\n    }"}
{"idx": 447, "target": 1, "func": "protected boolean copy(File from, File to) {\n        try {\n            if (!to.exists()) {\n                if (!to.createNewFile()) {\n                    log.error(sm.getString(\"fileNewFail\", to));\n                    return false;\n                }\n            }\n            java.io.FileInputStream is = new java.io.FileInputStream(from);\n            java.io.FileOutputStream os = new java.io.FileOutputStream(to,\n                    false);\n            byte[] buf = new byte[4096];\n            while (true) {\n                int len = is.read(buf);\n                if (len < 0)\n                    break;\n                os.write(buf, 0, len);\n            }\n            is.close();\n            os.close();\n        } catch (IOException e) {\n            log.error(sm.getString(\"farmWarDeployer.fileCopyFail\",\n                    from, to), e);\n            return false;\n        }\n        return true;\n    }"}
{"idx": 448, "target": 0, "func": "public byte[] getData() {\n        return data;\n    }"}
{"idx": 449, "target": 0, "func": "public void setData(byte[] data, int length) {\n        this.data = data;\n        this.dataLength = length;\n    }"}
{"idx": 450, "target": 1, "func": "protected void createMBeans() {\n\n        // Look up our global naming context\n        Context context = null;\n        try {\n            context = (Context) (new InitialContext()).lookup(\"java:/\");\n        } catch (NamingException e) {\n            log.error(\"No global naming context defined for server\");\n            return;\n        }\n\n        // Recurse through the defined global JNDI resources context\n        try {\n            createMBeans(\"\", context);\n        } catch (NamingException e) {\n            log.error(\"Exception processing Global JNDI Resources\", e);\n        }\n\n    }"}
{"idx": 451, "target": 0, "func": "public void removeConnector(String name) throws Exception {\n\n        // Acquire a reference to the component to be removed\n        ObjectName oname = new ObjectName(name);\n        Service service = getService(oname);\n        String port = oname.getKeyProperty(\"port\");\n        //String address = oname.getKeyProperty(\"address\");\n\n        Connector conns[] = service.findConnectors();\n\n        for (int i = 0; i < conns.length; i++) {\n            String connAddress = String.valueOf(conns[i].getProperty(\"address\"));\n            String connPort = \"\"+conns[i].getPort();\n\n            // if (((address.equals(\"null\")) &&\n            if ((connAddress==null) && port.equals(connPort)) {\n                service.removeConnector(conns[i]);\n                conns[i].destroy();\n                break;\n            }\n            // } else if (address.equals(connAddress))\n            if (port.equals(connPort)) {\n                // Remove this component from its parent component\n                service.removeConnector(conns[i]);\n                conns[i].destroy();\n                break;\n            }\n        }\n\n    }"}
{"idx": 452, "target": 1, "func": "protected void doLock(HttpServletRequest req, HttpServletResponse resp)\n        throws ServletException, IOException {\n\n        if (readOnly) {\n            resp.sendError(WebdavStatus.SC_FORBIDDEN);\n            return;\n        }\n\n        if (isLocked(req)) {\n            resp.sendError(WebdavStatus.SC_LOCKED);\n            return;\n        }\n\n        LockInfo lock = new LockInfo();\n\n        // Parsing lock request\n\n        // Parsing depth header\n\n        String depthStr = req.getHeader(\"Depth\");\n\n        if (depthStr == null) {\n            lock.depth = maxDepth;\n        } else {\n            if (depthStr.equals(\"0\")) {\n                lock.depth = 0;\n            } else {\n                lock.depth = maxDepth;\n            }\n        }\n\n        // Parsing timeout header\n\n        int lockDuration = DEFAULT_TIMEOUT;\n        String lockDurationStr = req.getHeader(\"Timeout\");\n        if (lockDurationStr == null) {\n            lockDuration = DEFAULT_TIMEOUT;\n        } else {\n            int commaPos = lockDurationStr.indexOf(\",\");\n            // If multiple timeouts, just use the first\n            if (commaPos != -1) {\n                lockDurationStr = lockDurationStr.substring(0,commaPos);\n            }\n            if (lockDurationStr.startsWith(\"Second-\")) {\n                lockDuration =\n                    (new Integer(lockDurationStr.substring(7))).intValue();\n            } else {\n                if (lockDurationStr.equalsIgnoreCase(\"infinity\")) {\n                    lockDuration = MAX_TIMEOUT;\n                } else {\n                    try {\n                        lockDuration =\n                            (new Integer(lockDurationStr)).intValue();\n                    } catch (NumberFormatException e) {\n                        lockDuration = MAX_TIMEOUT;\n                    }\n                }\n            }\n            if (lockDuration == 0) {\n                lockDuration = DEFAULT_TIMEOUT;\n            }\n            if (lockDuration > MAX_TIMEOUT) {\n                lockDuration = MAX_TIMEOUT;\n            }\n        }\n        lock.expiresAt = System.currentTimeMillis() + (lockDuration * 1000);\n\n        int lockRequestType = LOCK_CREATION;\n\n        Node lockInfoNode = null;\n\n        DocumentBuilder documentBuilder = getDocumentBuilder();\n\n        try {\n            Document document = documentBuilder.parse(new InputSource\n                (req.getInputStream()));\n\n            // Get the root element of the document\n            Element rootElement = document.getDocumentElement();\n            lockInfoNode = rootElement;\n        } catch (IOException e) {\n            lockRequestType = LOCK_REFRESH;\n        } catch (SAXException e) {\n            lockRequestType = LOCK_REFRESH;\n        }\n\n        if (lockInfoNode != null) {\n\n            // Reading lock information\n\n            NodeList childList = lockInfoNode.getChildNodes();\n            StringWriter strWriter = null;\n            DOMWriter domWriter = null;\n\n            Node lockScopeNode = null;\n            Node lockTypeNode = null;\n            Node lockOwnerNode = null;\n\n            for (int i=0; i < childList.getLength(); i++) {\n                Node currentNode = childList.item(i);\n                switch (currentNode.getNodeType()) {\n                case Node.TEXT_NODE:\n                    break;\n                case Node.ELEMENT_NODE:\n                    String nodeName = currentNode.getNodeName();\n                    if (nodeName.endsWith(\"lockscope\")) {\n                        lockScopeNode = currentNode;\n                    }\n                    if (nodeName.endsWith(\"locktype\")) {\n                        lockTypeNode = currentNode;\n                    }\n                    if (nodeName.endsWith(\"owner\")) {\n                        lockOwnerNode = currentNode;\n                    }\n                    break;\n                }\n            }\n\n            if (lockScopeNode != null) {\n\n                childList = lockScopeNode.getChildNodes();\n                for (int i=0; i < childList.getLength(); i++) {\n                    Node currentNode = childList.item(i);\n                    switch (currentNode.getNodeType()) {\n                    case Node.TEXT_NODE:\n                        break;\n                    case Node.ELEMENT_NODE:\n                        String tempScope = currentNode.getNodeName();\n                        if (tempScope.indexOf(':') != -1) {\n                            lock.scope = tempScope.substring\n                                (tempScope.indexOf(':') + 1);\n                        } else {\n                            lock.scope = tempScope;\n                        }\n                        break;\n                    }\n                }\n\n                if (lock.scope == null) {\n                    // Bad request\n                    resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n                }\n\n            } else {\n                // Bad request\n                resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n            }\n\n            if (lockTypeNode != null) {\n\n                childList = lockTypeNode.getChildNodes();\n                for (int i=0; i < childList.getLength(); i++) {\n                    Node currentNode = childList.item(i);\n                    switch (currentNode.getNodeType()) {\n                    case Node.TEXT_NODE:\n                        break;\n                    case Node.ELEMENT_NODE:\n                        String tempType = currentNode.getNodeName();\n                        if (tempType.indexOf(':') != -1) {\n                            lock.type =\n                                tempType.substring(tempType.indexOf(':') + 1);\n                        } else {\n                            lock.type = tempType;\n                        }\n                        break;\n                    }\n                }\n\n                if (lock.type == null) {\n                    // Bad request\n                    resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n                }\n\n            } else {\n                // Bad request\n                resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n            }\n\n            if (lockOwnerNode != null) {\n\n                childList = lockOwnerNode.getChildNodes();\n                for (int i=0; i < childList.getLength(); i++) {\n                    Node currentNode = childList.item(i);\n                    switch (currentNode.getNodeType()) {\n                    case Node.TEXT_NODE:\n                        lock.owner += currentNode.getNodeValue();\n                        break;\n                    case Node.ELEMENT_NODE:\n                        strWriter = new StringWriter();\n                        domWriter = new DOMWriter(strWriter, true);\n                        domWriter.print(currentNode);\n                        lock.owner += strWriter.toString();\n                        break;\n                    }\n                }\n\n                if (lock.owner == null) {\n                    // Bad request\n                    resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n                }\n\n            } else {\n                lock.owner = \"\";\n            }\n\n        }\n\n        String path = getRelativePath(req);\n\n        lock.path = path;\n\n        WebResource resource = resources.getResource(path);\n\n        Enumeration<LockInfo> locksList = null;\n\n        if (lockRequestType == LOCK_CREATION) {\n\n            // Generating lock id\n            String lockTokenStr = req.getServletPath() + \"-\" + lock.type + \"-\"\n                + lock.scope + \"-\" + req.getUserPrincipal() + \"-\"\n                + lock.depth + \"-\" + lock.owner + \"-\" + lock.tokens + \"-\"\n                + lock.expiresAt + \"-\" + System.currentTimeMillis() + \"-\"\n                + secret;\n            String lockToken = MD5Encoder.encode(md5Helper.digest(\n                    lockTokenStr.getBytes(StandardCharsets.ISO_8859_1)));\n\n            if (resource.isDirectory() && lock.depth == maxDepth) {\n\n                // Locking a collection (and all its member resources)\n\n                // Checking if a child resource of this collection is\n                // already locked\n                Vector<String> lockPaths = new Vector<>();\n                locksList = collectionLocks.elements();\n                while (locksList.hasMoreElements()) {\n                    LockInfo currentLock = locksList.nextElement();\n                    if (currentLock.hasExpired()) {\n                        resourceLocks.remove(currentLock.path);\n                        continue;\n                    }\n                    if ( (currentLock.path.startsWith(lock.path)) &&\n                         ((currentLock.isExclusive()) ||\n                          (lock.isExclusive())) ) {\n                        // A child collection of this collection is locked\n                        lockPaths.addElement(currentLock.path);\n                    }\n                }\n                locksList = resourceLocks.elements();\n                while (locksList.hasMoreElements()) {\n                    LockInfo currentLock = locksList.nextElement();\n                    if (currentLock.hasExpired()) {\n                        resourceLocks.remove(currentLock.path);\n                        continue;\n                    }\n                    if ( (currentLock.path.startsWith(lock.path)) &&\n                         ((currentLock.isExclusive()) ||\n                          (lock.isExclusive())) ) {\n                        // A child resource of this collection is locked\n                        lockPaths.addElement(currentLock.path);\n                    }\n                }\n\n                if (!lockPaths.isEmpty()) {\n\n                    // One of the child paths was locked\n                    // We generate a multistatus error report\n\n                    Enumeration<String> lockPathsList = lockPaths.elements();\n\n                    resp.setStatus(WebdavStatus.SC_CONFLICT);\n\n                    XMLWriter generatedXML = new XMLWriter();\n                    generatedXML.writeXMLHeader();\n\n                    generatedXML.writeElement(\"D\", DEFAULT_NAMESPACE,\n                            \"multistatus\", XMLWriter.OPENING);\n\n                    while (lockPathsList.hasMoreElements()) {\n                        generatedXML.writeElement(\"D\", \"response\",\n                                XMLWriter.OPENING);\n                        generatedXML.writeElement(\"D\", \"href\",\n                                XMLWriter.OPENING);\n                        generatedXML.writeText(lockPathsList.nextElement());\n                        generatedXML.writeElement(\"D\", \"href\",\n                                XMLWriter.CLOSING);\n                        generatedXML.writeElement(\"D\", \"status\",\n                                XMLWriter.OPENING);\n                        generatedXML\n                            .writeText(\"HTTP/1.1 \" + WebdavStatus.SC_LOCKED\n                                       + \" \" + WebdavStatus\n                                       .getStatusText(WebdavStatus.SC_LOCKED));\n                        generatedXML.writeElement(\"D\", \"status\",\n                                XMLWriter.CLOSING);\n\n                        generatedXML.writeElement(\"D\", \"response\",\n                                XMLWriter.CLOSING);\n                    }\n\n                    generatedXML.writeElement(\"D\", \"multistatus\",\n                            XMLWriter.CLOSING);\n\n                    Writer writer = resp.getWriter();\n                    writer.write(generatedXML.toString());\n                    writer.close();\n\n                    return;\n\n                }\n\n                boolean addLock = true;\n\n                // Checking if there is already a shared lock on this path\n                locksList = collectionLocks.elements();\n                while (locksList.hasMoreElements()) {\n\n                    LockInfo currentLock = locksList.nextElement();\n                    if (currentLock.path.equals(lock.path)) {\n\n                        if (currentLock.isExclusive()) {\n                            resp.sendError(WebdavStatus.SC_LOCKED);\n                            return;\n                        } else {\n                            if (lock.isExclusive()) {\n                                resp.sendError(WebdavStatus.SC_LOCKED);\n                                return;\n                            }\n                        }\n\n                        currentLock.tokens.addElement(lockToken);\n                        lock = currentLock;\n                        addLock = false;\n\n                    }\n\n                }\n\n                if (addLock) {\n                    lock.tokens.addElement(lockToken);\n                    collectionLocks.addElement(lock);\n                }\n\n            } else {\n\n                // Locking a single resource\n\n                // Retrieving an already existing lock on that resource\n                LockInfo presentLock = resourceLocks.get(lock.path);\n                if (presentLock != null) {\n\n                    if ((presentLock.isExclusive()) || (lock.isExclusive())) {\n                        // If either lock is exclusive, the lock can't be\n                        // granted\n                        resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);\n                        return;\n                    } else {\n                        presentLock.tokens.addElement(lockToken);\n                        lock = presentLock;\n                    }\n\n                } else {\n\n                    lock.tokens.addElement(lockToken);\n                    resourceLocks.put(lock.path, lock);\n\n                    // Checking if a resource exists at this path\n                    if (!resource.exists()) {\n\n                        // \"Creating\" a lock-null resource\n                        int slash = lock.path.lastIndexOf('/');\n                        String parentPath = lock.path.substring(0, slash);\n\n                        Vector<String> lockNulls =\n                            lockNullResources.get(parentPath);\n                        if (lockNulls == null) {\n                            lockNulls = new Vector<>();\n                            lockNullResources.put(parentPath, lockNulls);\n                        }\n\n                        lockNulls.addElement(lock.path);\n\n                    }\n                    // Add the Lock-Token header as by RFC 2518 8.10.1\n                    // - only do this for newly created locks\n                    resp.addHeader(\"Lock-Token\", \"<opaquelocktoken:\"\n                                   + lockToken + \">\");\n                }\n\n            }\n\n        }\n\n        if (lockRequestType == LOCK_REFRESH) {\n\n            String ifHeader = req.getHeader(\"If\");\n            if (ifHeader == null)\n                ifHeader = \"\";\n\n            // Checking resource locks\n\n            LockInfo toRenew = resourceLocks.get(path);\n            Enumeration<String> tokenList = null;\n\n            if (toRenew != null) {\n                // At least one of the tokens of the locks must have been given\n                tokenList = toRenew.tokens.elements();\n                while (tokenList.hasMoreElements()) {\n                    String token = tokenList.nextElement();\n                    if (ifHeader.indexOf(token) != -1) {\n                        toRenew.expiresAt = lock.expiresAt;\n                        lock = toRenew;\n                    }\n                }\n            }\n\n            // Checking inheritable collection locks\n\n            Enumeration<LockInfo> collectionLocksList =\n                collectionLocks.elements();\n            while (collectionLocksList.hasMoreElements()) {\n                toRenew = collectionLocksList.nextElement();\n                if (path.equals(toRenew.path)) {\n\n                    tokenList = toRenew.tokens.elements();\n                    while (tokenList.hasMoreElements()) {\n                        String token = tokenList.nextElement();\n                        if (ifHeader.indexOf(token) != -1) {\n                            toRenew.expiresAt = lock.expiresAt;\n                            lock = toRenew;\n                        }\n                    }\n\n                }\n            }\n\n        }\n\n        // Set the status, then generate the XML response containing\n        // the lock information\n        XMLWriter generatedXML = new XMLWriter();\n        generatedXML.writeXMLHeader();\n        generatedXML.writeElement(\"D\", DEFAULT_NAMESPACE, \"prop\",\n                XMLWriter.OPENING);\n\n        generatedXML.writeElement(\"D\", \"lockdiscovery\", XMLWriter.OPENING);\n\n        lock.toXML(generatedXML);\n\n        generatedXML.writeElement(\"D\", \"lockdiscovery\", XMLWriter.CLOSING);\n\n        generatedXML.writeElement(\"D\", \"prop\", XMLWriter.CLOSING);\n\n        resp.setStatus(WebdavStatus.SC_OK);\n        resp.setContentType(\"text/xml; charset=UTF-8\");\n        Writer writer = resp.getWriter();\n        writer.write(generatedXML.toString());\n        writer.close();\n\n    }"}
{"idx": 453, "target": 0, "func": "protected void doLock(HttpServletRequest req, HttpServletResponse resp)\n        throws ServletException, IOException {\n\n        if (readOnly) {\n            resp.sendError(WebdavStatus.SC_FORBIDDEN);\n            return;\n        }\n\n        if (isLocked(req)) {\n            resp.sendError(WebdavStatus.SC_LOCKED);\n            return;\n        }\n\n        LockInfo lock = new LockInfo();\n\n        // Parsing lock request\n\n        // Parsing depth header\n\n        String depthStr = req.getHeader(\"Depth\");\n\n        if (depthStr == null) {\n            lock.depth = maxDepth;\n        } else {\n            if (depthStr.equals(\"0\")) {\n                lock.depth = 0;\n            } else {\n                lock.depth = maxDepth;\n            }\n        }\n\n        // Parsing timeout header\n\n        int lockDuration = DEFAULT_TIMEOUT;\n        String lockDurationStr = req.getHeader(\"Timeout\");\n        if (lockDurationStr == null) {\n            lockDuration = DEFAULT_TIMEOUT;\n        } else {\n            int commaPos = lockDurationStr.indexOf(\",\");\n            // If multiple timeouts, just use the first\n            if (commaPos != -1) {\n                lockDurationStr = lockDurationStr.substring(0,commaPos);\n            }\n            if (lockDurationStr.startsWith(\"Second-\")) {\n                lockDuration =\n                    (new Integer(lockDurationStr.substring(7))).intValue();\n            } else {\n                if (lockDurationStr.equalsIgnoreCase(\"infinity\")) {\n                    lockDuration = MAX_TIMEOUT;\n                } else {\n                    try {\n                        lockDuration =\n                            (new Integer(lockDurationStr)).intValue();\n                    } catch (NumberFormatException e) {\n                        lockDuration = MAX_TIMEOUT;\n                    }\n                }\n            }\n            if (lockDuration == 0) {\n                lockDuration = DEFAULT_TIMEOUT;\n            }\n            if (lockDuration > MAX_TIMEOUT) {\n                lockDuration = MAX_TIMEOUT;\n            }\n        }\n        lock.expiresAt = System.currentTimeMillis() + (lockDuration * 1000);\n\n        int lockRequestType = LOCK_CREATION;\n\n        Node lockInfoNode = null;\n\n        DocumentBuilder documentBuilder = getDocumentBuilder();\n\n        try {\n            Document document = documentBuilder.parse(new InputSource\n                (req.getInputStream()));\n\n            // Get the root element of the document\n            Element rootElement = document.getDocumentElement();\n            lockInfoNode = rootElement;\n        } catch (IOException e) {\n            lockRequestType = LOCK_REFRESH;\n        } catch (SAXException e) {\n            lockRequestType = LOCK_REFRESH;\n        }\n\n        if (lockInfoNode != null) {\n\n            // Reading lock information\n\n            NodeList childList = lockInfoNode.getChildNodes();\n            StringWriter strWriter = null;\n            DOMWriter domWriter = null;\n\n            Node lockScopeNode = null;\n            Node lockTypeNode = null;\n            Node lockOwnerNode = null;\n\n            for (int i=0; i < childList.getLength(); i++) {\n                Node currentNode = childList.item(i);\n                switch (currentNode.getNodeType()) {\n                case Node.TEXT_NODE:\n                    break;\n                case Node.ELEMENT_NODE:\n                    String nodeName = currentNode.getNodeName();\n                    if (nodeName.endsWith(\"lockscope\")) {\n                        lockScopeNode = currentNode;\n                    }\n                    if (nodeName.endsWith(\"locktype\")) {\n                        lockTypeNode = currentNode;\n                    }\n                    if (nodeName.endsWith(\"owner\")) {\n                        lockOwnerNode = currentNode;\n                    }\n                    break;\n                }\n            }\n\n            if (lockScopeNode != null) {\n\n                childList = lockScopeNode.getChildNodes();\n                for (int i=0; i < childList.getLength(); i++) {\n                    Node currentNode = childList.item(i);\n                    switch (currentNode.getNodeType()) {\n                    case Node.TEXT_NODE:\n                        break;\n                    case Node.ELEMENT_NODE:\n                        String tempScope = currentNode.getNodeName();\n                        if (tempScope.indexOf(':') != -1) {\n                            lock.scope = tempScope.substring\n                                (tempScope.indexOf(':') + 1);\n                        } else {\n                            lock.scope = tempScope;\n                        }\n                        break;\n                    }\n                }\n\n                if (lock.scope == null) {\n                    // Bad request\n                    resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n                }\n\n            } else {\n                // Bad request\n                resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n            }\n\n            if (lockTypeNode != null) {\n\n                childList = lockTypeNode.getChildNodes();\n                for (int i=0; i < childList.getLength(); i++) {\n                    Node currentNode = childList.item(i);\n                    switch (currentNode.getNodeType()) {\n                    case Node.TEXT_NODE:\n                        break;\n                    case Node.ELEMENT_NODE:\n                        String tempType = currentNode.getNodeName();\n                        if (tempType.indexOf(':') != -1) {\n                            lock.type =\n                                tempType.substring(tempType.indexOf(':') + 1);\n                        } else {\n                            lock.type = tempType;\n                        }\n                        break;\n                    }\n                }\n\n                if (lock.type == null) {\n                    // Bad request\n                    resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n                }\n\n            } else {\n                // Bad request\n                resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n            }\n\n            if (lockOwnerNode != null) {\n\n                childList = lockOwnerNode.getChildNodes();\n                for (int i=0; i < childList.getLength(); i++) {\n                    Node currentNode = childList.item(i);\n                    switch (currentNode.getNodeType()) {\n                    case Node.TEXT_NODE:\n                        lock.owner += currentNode.getNodeValue();\n                        break;\n                    case Node.ELEMENT_NODE:\n                        strWriter = new StringWriter();\n                        domWriter = new DOMWriter(strWriter, true);\n                        domWriter.print(currentNode);\n                        lock.owner += strWriter.toString();\n                        break;\n                    }\n                }\n\n                if (lock.owner == null) {\n                    // Bad request\n                    resp.setStatus(WebdavStatus.SC_BAD_REQUEST);\n                }\n\n            } else {\n                lock.owner = \"\";\n            }\n\n        }\n\n        String path = getRelativePath(req);\n\n        lock.path = path;\n\n        WebResource resource = resources.getResource(path);\n\n        Enumeration<LockInfo> locksList = null;\n\n        if (lockRequestType == LOCK_CREATION) {\n\n            // Generating lock id\n            String lockTokenStr = req.getServletPath() + \"-\" + lock.type + \"-\"\n                + lock.scope + \"-\" + req.getUserPrincipal() + \"-\"\n                + lock.depth + \"-\" + lock.owner + \"-\" + lock.tokens + \"-\"\n                + lock.expiresAt + \"-\" + System.currentTimeMillis() + \"-\"\n                + secret;\n            String lockToken = MD5Encoder.encode(md5Helper.digest(\n                    lockTokenStr.getBytes(StandardCharsets.ISO_8859_1)));\n\n            if (resource.isDirectory() && lock.depth == maxDepth) {\n\n                // Locking a collection (and all its member resources)\n\n                // Checking if a child resource of this collection is\n                // already locked\n                Vector<String> lockPaths = new Vector<>();\n                locksList = collectionLocks.elements();\n                while (locksList.hasMoreElements()) {\n                    LockInfo currentLock = locksList.nextElement();\n                    if (currentLock.hasExpired()) {\n                        resourceLocks.remove(currentLock.path);\n                        continue;\n                    }\n                    if ( (currentLock.path.startsWith(lock.path)) &&\n                         ((currentLock.isExclusive()) ||\n                          (lock.isExclusive())) ) {\n                        // A child collection of this collection is locked\n                        lockPaths.addElement(currentLock.path);\n                    }\n                }\n                locksList = resourceLocks.elements();\n                while (locksList.hasMoreElements()) {\n                    LockInfo currentLock = locksList.nextElement();\n                    if (currentLock.hasExpired()) {\n                        resourceLocks.remove(currentLock.path);\n                        continue;\n                    }\n                    if ( (currentLock.path.startsWith(lock.path)) &&\n                         ((currentLock.isExclusive()) ||\n                          (lock.isExclusive())) ) {\n                        // A child resource of this collection is locked\n                        lockPaths.addElement(currentLock.path);\n                    }\n                }\n\n                if (!lockPaths.isEmpty()) {\n\n                    // One of the child paths was locked\n                    // We generate a multistatus error report\n\n                    Enumeration<String> lockPathsList = lockPaths.elements();\n\n                    resp.setStatus(WebdavStatus.SC_CONFLICT);\n\n                    XMLWriter generatedXML = new XMLWriter();\n                    generatedXML.writeXMLHeader();\n\n                    generatedXML.writeElement(\"D\", DEFAULT_NAMESPACE,\n                            \"multistatus\", XMLWriter.OPENING);\n\n                    while (lockPathsList.hasMoreElements()) {\n                        generatedXML.writeElement(\"D\", \"response\",\n                                XMLWriter.OPENING);\n                        generatedXML.writeElement(\"D\", \"href\",\n                                XMLWriter.OPENING);\n                        generatedXML.writeText(lockPathsList.nextElement());\n                        generatedXML.writeElement(\"D\", \"href\",\n                                XMLWriter.CLOSING);\n                        generatedXML.writeElement(\"D\", \"status\",\n                                XMLWriter.OPENING);\n                        generatedXML\n                            .writeText(\"HTTP/1.1 \" + WebdavStatus.SC_LOCKED\n                                       + \" \" + WebdavStatus\n                                       .getStatusText(WebdavStatus.SC_LOCKED));\n                        generatedXML.writeElement(\"D\", \"status\",\n                                XMLWriter.CLOSING);\n\n                        generatedXML.writeElement(\"D\", \"response\",\n                                XMLWriter.CLOSING);\n                    }\n\n                    generatedXML.writeElement(\"D\", \"multistatus\",\n                            XMLWriter.CLOSING);\n\n                    Writer writer = resp.getWriter();\n                    writer.write(generatedXML.toString());\n                    writer.close();\n\n                    return;\n\n                }\n\n                boolean addLock = true;\n\n                // Checking if there is already a shared lock on this path\n                locksList = collectionLocks.elements();\n                while (locksList.hasMoreElements()) {\n\n                    LockInfo currentLock = locksList.nextElement();\n                    if (currentLock.path.equals(lock.path)) {\n\n                        if (currentLock.isExclusive()) {\n                            resp.sendError(WebdavStatus.SC_LOCKED);\n                            return;\n                        } else {\n                            if (lock.isExclusive()) {\n                                resp.sendError(WebdavStatus.SC_LOCKED);\n                                return;\n                            }\n                        }\n\n                        currentLock.tokens.addElement(lockToken);\n                        lock = currentLock;\n                        addLock = false;\n\n                    }\n\n                }\n\n                if (addLock) {\n                    lock.tokens.addElement(lockToken);\n                    collectionLocks.addElement(lock);\n                }\n\n            } else {\n\n                // Locking a single resource\n\n                // Retrieving an already existing lock on that resource\n                LockInfo presentLock = resourceLocks.get(lock.path);\n                if (presentLock != null) {\n\n                    if ((presentLock.isExclusive()) || (lock.isExclusive())) {\n                        // If either lock is exclusive, the lock can't be\n                        // granted\n                        resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);\n                        return;\n                    } else {\n                        presentLock.tokens.addElement(lockToken);\n                        lock = presentLock;\n                    }\n\n                } else {\n\n                    lock.tokens.addElement(lockToken);\n                    resourceLocks.put(lock.path, lock);\n\n                    // Checking if a resource exists at this path\n                    if (!resource.exists()) {\n\n                        // \"Creating\" a lock-null resource\n                        int slash = lock.path.lastIndexOf('/');\n                        String parentPath = lock.path.substring(0, slash);\n\n                        Vector<String> lockNulls =\n                            lockNullResources.get(parentPath);\n                        if (lockNulls == null) {\n                            lockNulls = new Vector<>();\n                            lockNullResources.put(parentPath, lockNulls);\n                        }\n\n                        lockNulls.addElement(lock.path);\n\n                    }\n                    // Add the Lock-Token header as by RFC 2518 8.10.1\n                    // - only do this for newly created locks\n                    resp.addHeader(\"Lock-Token\", \"<opaquelocktoken:\"\n                                   + lockToken + \">\");\n                }\n\n            }\n\n        }\n\n        if (lockRequestType == LOCK_REFRESH) {\n\n            String ifHeader = req.getHeader(\"If\");\n            if (ifHeader == null)\n                ifHeader = \"\";\n\n            // Checking resource locks\n\n            LockInfo toRenew = resourceLocks.get(path);\n            Enumeration<String> tokenList = null;\n\n            if (toRenew != null) {\n                // At least one of the tokens of the locks must have been given\n                tokenList = toRenew.tokens.elements();\n                while (tokenList.hasMoreElements()) {\n                    String token = tokenList.nextElement();\n                    if (ifHeader.indexOf(token) != -1) {\n                        toRenew.expiresAt = lock.expiresAt;\n                        lock = toRenew;\n                    }\n                }\n            }\n\n            // Checking inheritable collection locks\n\n            Enumeration<LockInfo> collectionLocksList =\n                collectionLocks.elements();\n            while (collectionLocksList.hasMoreElements()) {\n                toRenew = collectionLocksList.nextElement();\n                if (path.equals(toRenew.path)) {\n\n                    tokenList = toRenew.tokens.elements();\n                    while (tokenList.hasMoreElements()) {\n                        String token = tokenList.nextElement();\n                        if (ifHeader.indexOf(token) != -1) {\n                            toRenew.expiresAt = lock.expiresAt;\n                            lock = toRenew;\n                        }\n                    }\n\n                }\n            }\n\n        }\n\n        // Set the status, then generate the XML response containing\n        // the lock information\n        XMLWriter generatedXML = new XMLWriter();\n        generatedXML.writeXMLHeader();\n        generatedXML.writeElement(\"D\", DEFAULT_NAMESPACE, \"prop\",\n                XMLWriter.OPENING);\n\n        generatedXML.writeElement(\"D\", \"lockdiscovery\", XMLWriter.OPENING);\n\n        lock.toXML(generatedXML);\n\n        generatedXML.writeElement(\"D\", \"lockdiscovery\", XMLWriter.CLOSING);\n\n        generatedXML.writeElement(\"D\", \"prop\", XMLWriter.CLOSING);\n\n        resp.setStatus(WebdavStatus.SC_OK);\n        resp.setContentType(\"text/xml; charset=UTF-8\");\n        Writer writer = resp.getWriter();\n        writer.write(generatedXML.toString());\n        writer.close();\n\n    }"}
{"idx": 454, "target": 1, "func": "@Override\n    public void init()\n        throws ServletException {\n\n        super.init();\n\n        if (getServletConfig().getInitParameter(\"secret\") != null)\n            secret = getServletConfig().getInitParameter(\"secret\");\n\n        if (getServletConfig().getInitParameter(\"maxDepth\") != null)\n            maxDepth = Integer.parseInt(\n                    getServletConfig().getInitParameter(\"maxDepth\"));\n\n        if (getServletConfig().getInitParameter(\"allowSpecialPaths\") != null)\n            allowSpecialPaths = Boolean.parseBoolean(\n                    getServletConfig().getInitParameter(\"allowSpecialPaths\"));\n\n        // Load the MD5 helper used to calculate signatures.\n        try {\n            md5Helper = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new UnavailableException(\"No MD5\");\n        }\n\n    }"}
{"idx": 455, "target": 0, "func": "@Override\n    public void save(Session session) throws IOException {\n\n        // Open an output stream to the specified pathname, if any\n        File file = file(session.getIdInternal());\n        if (file == null) {\n            return;\n        }\n        if (manager.getContext().getLogger().isDebugEnabled()) {\n            manager.getContext().getLogger().debug(sm.getString(getStoreName()+\".saving\",\n                             session.getIdInternal(), file.getAbsolutePath()));\n        }\n        FileOutputStream fos = null;\n        ObjectOutputStream oos = null;\n        try {\n            fos = new FileOutputStream(file.getAbsolutePath());\n            oos = new ObjectOutputStream(new BufferedOutputStream(fos));\n        } catch (IOException e) {\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException f) {\n                    // Ignore\n                }\n            }\n            throw e;\n        }\n\n        try {\n            ((StandardSession)session).writeObjectData(oos);\n        } finally {\n            oos.close();\n        }\n\n    }"}
{"idx": 456, "target": 1, "func": "@Override\n    public int getSize() throws IOException {\n\n        // Acquire the list of files in our storage directory\n        File file = directory();\n        if (file == null) {\n            return (0);\n        }\n        String files[] = file.list();\n\n        // Figure out which files are sessions\n        int keycount = 0;\n        for (int i = 0; i < files.length; i++) {\n            if (files[i].endsWith(FILE_EXT)) {\n                keycount++;\n            }\n        }\n        return (keycount);\n\n    }"}
{"idx": 457, "target": 0, "func": "@Override\n    public void remove(String id) throws IOException {\n\n        File file = file(id);\n        if (file == null) {\n            return;\n        }\n        if (manager.getContext().getLogger().isDebugEnabled()) {\n            manager.getContext().getLogger().debug(sm.getString(getStoreName()+\".removing\",\n                             id, file.getAbsolutePath()));\n        }\n        file.delete();\n\n    }"}
{"idx": 458, "target": 0, "func": "@Override\n    public void save(Session session) throws IOException {\n        ObjectOutputStream oos = null;\n        ByteArrayOutputStream bos = null;\n        ByteArrayInputStream bis = null;\n        InputStream in = null;\n\n        synchronized (this) {\n            int numberOfTries = 2;\n            while (numberOfTries > 0) {\n                Connection _conn = getConnection();\n                if (_conn == null) {\n                    return;\n                }\n\n                try {\n                    // If sessions already exist in DB, remove and insert again.\n                    // TODO:\n                    // * Check if ID exists in database and if so use UPDATE.\n                    remove(session.getIdInternal(), _conn);\n\n                    bos = new ByteArrayOutputStream();\n                    oos = new ObjectOutputStream(new BufferedOutputStream(bos));\n\n                    ((StandardSession) session).writeObjectData(oos);\n                    oos.close();\n                    oos = null;\n                    byte[] obs = bos.toByteArray();\n                    int size = obs.length;\n                    bis = new ByteArrayInputStream(obs, 0, size);\n                    in = new BufferedInputStream(bis, size);\n\n                    if (preparedSaveSql == null) {\n                        String saveSql = \"INSERT INTO \" + sessionTable + \" (\"\n                           + sessionIdCol + \", \" + sessionAppCol + \", \"\n                           + sessionDataCol + \", \" + sessionValidCol\n                           + \", \" + sessionMaxInactiveCol + \", \"\n                           + sessionLastAccessedCol\n                           + \") VALUES (?, ?, ?, ?, ?, ?)\";\n                       preparedSaveSql = _conn.prepareStatement(saveSql);\n                    }\n\n                    preparedSaveSql.setString(1, session.getIdInternal());\n                    preparedSaveSql.setString(2, getName());\n                    preparedSaveSql.setBinaryStream(3, in, size);\n                    preparedSaveSql.setString(4, session.isValid() ? \"1\" : \"0\");\n                    preparedSaveSql.setInt(5, session.getMaxInactiveInterval());\n                    preparedSaveSql.setLong(6, session.getLastAccessedTime());\n                    preparedSaveSql.execute();\n                    // Break out after the finally block\n                    numberOfTries = 0;\n                } catch (SQLException e) {\n                    manager.getContext().getLogger().error(sm.getString(getStoreName() + \".SQLException\", e));\n                    if (dbConnection != null)\n                        close(dbConnection);\n                } catch (IOException e) {\n                    // Ignore\n                } finally {\n                    if (oos != null) {\n                        oos.close();\n                    }\n                    if (bis != null) {\n                        bis.close();\n                    }\n                    if (in != null) {\n                        in.close();\n                    }\n\n                    release(_conn);\n                }\n                numberOfTries--;\n            }\n        }\n\n        if (manager.getContext().getLogger().isDebugEnabled()) {\n            manager.getContext().getLogger().debug(sm.getString(getStoreName() + \".saving\",\n                    session.getIdInternal(), sessionTable));\n        }\n    }"}
{"idx": 459, "target": 0, "func": "protected Connection open() throws SQLException {\n\n        // Do nothing if there is a database connection already open\n        if (dbConnection != null)\n            return (dbConnection);\n\n        if (dataSourceName != null && dataSource == null) {\n            Context initCtx;\n            try {\n                initCtx = new InitialContext();\n                Context envCtx = (Context) initCtx.lookup(\"java:comp/env\");\n                this.dataSource = (DataSource) envCtx.lookup(this.dataSourceName);\n            } catch (NamingException e) {\n                manager.getContext().getLogger().error(\n                        sm.getString(getStoreName() + \".wrongDataSource\",\n                                this.dataSourceName), e);\n           }\n        }\n\n        if (dataSource != null) {\n            return dataSource.getConnection();\n        }\n\n        // Instantiate our database driver if necessary\n        if (driver == null) {\n            try {\n                Class<?> clazz = Class.forName(driverName);\n                driver = (Driver) clazz.newInstance();\n            } catch (ClassNotFoundException ex) {\n                manager.getContext().getLogger().error(sm.getString(getStoreName() + \".checkConnectionClassNotFoundException\",\n                        ex.toString()));\n            } catch (InstantiationException ex) {\n                manager.getContext().getLogger().error(sm.getString(getStoreName() + \".checkConnectionClassNotFoundException\",\n                        ex.toString()));\n            } catch (IllegalAccessException ex) {\n                manager.getContext().getLogger().error(sm.getString(getStoreName() + \".checkConnectionClassNotFoundException\",\n                        ex.toString()));\n            }\n        }\n\n        // Open a new connection\n        Properties props = new Properties();\n        if (connectionName != null)\n            props.put(\"user\", connectionName);\n        if (connectionPassword != null)\n            props.put(\"password\", connectionPassword);\n        dbConnection = driver.connect(connectionURL, props);\n        dbConnection.setAutoCommit(true);\n        return (dbConnection);\n\n    }"}
{"idx": 460, "target": 1, "func": "@SuppressWarnings(\"null\")\n    protected void doUnload() throws IOException {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"standardManager.unloading.debug\"));\n\n        if (sessions.isEmpty()) {\n            log.debug(sm.getString(\"standardManager.unloading.nosessions\"));\n            return; // nothing to do\n        }\n\n        // Open an output stream to the specified pathname, if any\n        File file = file();\n        if (file == null)\n            return;\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"standardManager.unloading\", pathname));\n        FileOutputStream fos = null;\n        BufferedOutputStream bos = null;\n        ObjectOutputStream oos = null;\n        boolean error = false;\n        try {\n            fos = new FileOutputStream(file.getAbsolutePath());\n            bos = new BufferedOutputStream(fos);\n            oos = new ObjectOutputStream(bos);\n        } catch (IOException e) {\n            error = true;\n            log.error(sm.getString(\"standardManager.unloading.ioe\", e), e);\n            throw e;\n        } finally {\n            if (error) {\n                if (oos != null) {\n                    try {\n                        oos.close();\n                    } catch (IOException ioe) {\n                        // Ignore\n                    }\n                }\n                if (bos != null) {\n                    try {\n                        bos.close();\n                    } catch (IOException ioe) {\n                        // Ignore\n                    }\n                }\n                if (fos != null) {\n                    try {\n                        fos.close();\n                    } catch (IOException ioe) {\n                        // Ignore\n                    }\n                }\n            }\n        }\n\n        // Write the number of active sessions, followed by the details\n        ArrayList<StandardSession> list = new ArrayList<>();\n        synchronized (sessions) {\n            if (log.isDebugEnabled())\n                log.debug(\"Unloading \" + sessions.size() + \" sessions\");\n            try {\n                // oos can't be null here\n                oos.writeObject(new Integer(sessions.size()));\n                Iterator<Session> elements = sessions.values().iterator();\n                while (elements.hasNext()) {\n                    StandardSession session =\n                        (StandardSession) elements.next();\n                    list.add(session);\n                    session.passivate();\n                    session.writeObjectData(oos);\n                }\n            } catch (IOException e) {\n                log.error(sm.getString(\"standardManager.unloading.ioe\", e), e);\n                try {\n                    oos.close();\n                } catch (IOException f) {\n                    // Ignore\n                }\n                throw e;\n            }\n        }\n\n        // Flush and close the output stream\n        try {\n            oos.flush();\n        } finally {\n            try {\n                oos.close();\n            } catch (IOException f) {\n                // Ignore\n            }\n        }\n\n        // Expire all the sessions we just wrote\n        if (log.isDebugEnabled())\n            log.debug(\"Expiring \" + list.size() + \" persisted sessions\");\n        Iterator<StandardSession> expires = list.iterator();\n        while (expires.hasNext()) {\n            StandardSession session = expires.next();\n            try {\n                session.expire(false);\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n            } finally {\n                session.recycle();\n            }\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Unloading complete\");\n\n    }"}
{"idx": 461, "target": 1, "func": "private static void loadProperties() {\n\n        InputStream is = null;\n        Throwable error = null;\n\n        try {\n            String configUrl = getConfigUrl();\n            if (configUrl != null) {\n                is = (new URL(configUrl)).openStream();\n            }\n        } catch (Throwable t) {\n            handleThrowable(t);\n        }\n\n        if (is == null) {\n            try {\n                File home = new File(Bootstrap.getCatalinaBase());\n                File conf = new File(home, \"conf\");\n                File propsFile = new File(conf, \"catalina.properties\");\n                is = new FileInputStream(propsFile);\n            } catch (Throwable t) {\n                handleThrowable(t);\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = CatalinaProperties.class.getResourceAsStream\n                    (\"/org/apache/catalina/startup/catalina.properties\");\n            } catch (Throwable t) {\n                handleThrowable(t);\n            }\n        }\n\n        if (is != null) {\n            try {\n                properties = new Properties();\n                properties.load(is);\n                is.close();\n            } catch (Throwable t) {\n                handleThrowable(t);\n                error = t;\n            }\n        }\n\n        if ((is == null) || (error != null)) {\n            // Do something\n            log.warn(\"Failed to load catalina.properties\", error);\n            // That's fine - we have reasonable defaults.\n            properties=new Properties();\n        }\n\n        // Register the properties as system properties\n        Enumeration<?> enumeration = properties.propertyNames();\n        while (enumeration.hasMoreElements()) {\n            String name = (String) enumeration.nextElement();\n            String value = properties.getProperty(name);\n            if (value != null) {\n                System.setProperty(name, value);\n            }\n        }\n    }"}
{"idx": 462, "target": 1, "func": "public static ClassLoader createClassLoader(File unpacked[],\n                                                File packed[],\n                                                final ClassLoader parent)\n        throws Exception {\n\n        if (log.isDebugEnabled())\n            log.debug(\"Creating new class loader\");\n\n        // Construct the \"class path\" for this class loader\n        Set<URL> set = new LinkedHashSet<>();\n\n        // Add unpacked directories\n        if (unpacked != null) {\n            for (int i = 0; i < unpacked.length; i++)  {\n                File file = unpacked[i];\n                if (!file.exists() || !file.canRead())\n                    continue;\n                file = new File(file.getCanonicalPath() + File.separator);\n                URL url = file.toURI().toURL();\n                if (log.isDebugEnabled())\n                    log.debug(\"  Including directory \" + url);\n                set.add(url);\n            }\n        }\n\n        // Add packed directory JAR files\n        if (packed != null) {\n            for (int i = 0; i < packed.length; i++) {\n                File directory = packed[i];\n                if (!directory.isDirectory() || !directory.exists() ||\n                    !directory.canRead())\n                    continue;\n                String filenames[] = directory.list();\n                for (int j = 0; j < filenames.length; j++) {\n                    String filename = filenames[j].toLowerCase(Locale.ENGLISH);\n                    if (!filename.endsWith(\".jar\"))\n                        continue;\n                    File file = new File(directory, filenames[j]);\n                    if (log.isDebugEnabled())\n                        log.debug(\"  Including jar file \" + file.getAbsolutePath());\n                    URL url = file.toURI().toURL();\n                    set.add(url);\n                }\n            }\n        }\n\n        // Construct the class loader itself\n        final URL[] array = set.toArray(new URL[set.size()]);\n        return AccessController.doPrivileged(\n                new PrivilegedAction<URLClassLoader>() {\n                    @Override\n                    public URLClassLoader run() {\n                        if (parent == null)\n                            return new URLClassLoader(array);\n                        else\n                            return new URLClassLoader(array, parent);\n                    }\n                });\n    }"}
{"idx": 463, "target": 0, "func": "public static boolean deleteDir(File dir) {\n        return deleteDir(dir, true);\n    }"}
{"idx": 464, "target": 0, "func": "public static String expand(Host host, URL war, String pathname)\n        throws IOException {\n\n        // Make sure that there is no such directory already existing\n        File docBase = new File(host.getAppBaseFile(), pathname);\n        if (docBase.exists()) {\n            // War file is already installed\n            return (docBase.getAbsolutePath());\n        }\n\n        // Create the new document base directory\n        if(!docBase.mkdir() && !docBase.isDirectory())\n            throw new IOException(sm.getString(\"expandWar.createFailed\", docBase));\n\n        // Expand the WAR into the new document base directory\n        String canonicalDocBasePrefix = docBase.getCanonicalPath();\n        if (!canonicalDocBasePrefix.endsWith(File.separator)) {\n            canonicalDocBasePrefix += File.separator;\n        }\n        JarURLConnection juc = (JarURLConnection) war.openConnection();\n        juc.setUseCaches(false);\n        JarFile jarFile = null;\n        InputStream input = null;\n        boolean success = false;\n        try {\n            jarFile = juc.getJarFile();\n            Enumeration<JarEntry> jarEntries = jarFile.entries();\n            while (jarEntries.hasMoreElements()) {\n                JarEntry jarEntry = jarEntries.nextElement();\n                String name = jarEntry.getName();\n                File expandedFile = new File(docBase, name);\n                if (!expandedFile.getCanonicalPath().startsWith(\n                        canonicalDocBasePrefix)) {\n                    // Trying to expand outside the docBase\n                    // Throw an exception to stop the deployment\n                    throw new IllegalArgumentException(\n                            sm.getString(\"expandWar.illegalPath\",war, name,\n                                    expandedFile.getCanonicalPath(),\n                                    canonicalDocBasePrefix));\n                }\n                int last = name.lastIndexOf('/');\n                if (last >= 0) {\n                    File parent = new File(docBase,\n                                           name.substring(0, last));\n                    if (!parent.mkdirs() && !parent.isDirectory()) {\n                        throw new IOException(\n                                sm.getString(\"expandWar.createFailed\", parent));\n                    }\n                }\n                if (name.endsWith(\"/\")) {\n                    continue;\n                }\n                input = jarFile.getInputStream(jarEntry);\n\n                if(null == input)\n                    throw new ZipException(sm.getString(\"expandWar.missingJarEntry\", jarEntry.getName()));\n\n                // Bugzilla 33636\n                expand(input, expandedFile);\n                long lastModified = jarEntry.getTime();\n                if ((lastModified != -1) && (lastModified != 0)) {\n                    expandedFile.setLastModified(lastModified);\n                }\n\n                input.close();\n                input = null;\n            }\n            success = true;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (!success) {\n                // If something went wrong, delete expanded dir to keep things\n                // clean\n                deleteDir(docBase);\n            }\n            if (input != null) {\n                try {\n                    input.close();\n                } catch (IOException ioe) {\n                    // Ignore\n                }\n                input = null;\n            }\n            if (jarFile != null) {\n                try {\n                    jarFile.close();\n                } catch (IOException ioe) {\n                    // Ignore\n                }\n                jarFile = null;\n            }\n        }\n\n        // Return the absolute path to our new document base directory\n        return (docBase.getAbsolutePath());\n\n    }"}
{"idx": 465, "target": 0, "func": "@Override\n    public String getMBeanKeyProperties() {\n        Container c = this;\n        StringBuilder keyProperties = new StringBuilder();\n        int containerCount = 0;\n\n        // Work up container hierarchy, add a component to the name for\n        // each container\n        while (!(c instanceof Engine)) {\n            if (c instanceof Context) {\n                keyProperties.append(\",context=\");\n                ContextName cn = new ContextName(c.getName());\n                keyProperties.append(cn.getDisplayName());\n            } else if (c instanceof Host) {\n                keyProperties.append(\",host=\");\n                keyProperties.append(c.getName());\n            } else if (c == null) {\n                // May happen in unit testing and/or some embedding scenarios\n                keyProperties.append(\",container\");\n                keyProperties.append(containerCount++);\n                keyProperties.append(\"=null\");\n                break;\n            } else {\n                // Should never happen...\n                keyProperties.append(\",container\");\n                keyProperties.append(containerCount++);\n                keyProperties.append('=');\n                keyProperties.append(c.getName());\n            }\n            c = c.getParent();\n        }\n        return keyProperties.toString();\n    }"}
{"idx": 466, "target": 1, "func": "@Override\n    public void addRuleInstances(Digester digester) {\n\n        String pattern = prefix;\n\n        for (int i = 0; i < MAX_NESTED_REALM_LEVELS; i++) {\n\n            if (i > 0) {\n                pattern += \"/\";\n            }\n            pattern += \"Realm\";\n\n            digester.addObjectCreate(pattern,\n                                     null, // MUST be specified in the element,\n                                     \"className\");\n            digester.addSetProperties(pattern);\n            if (i == 0) {\n                digester.addSetNext(pattern,\n                                    \"setRealm\",\n                                    \"org.apache.catalina.Realm\");\n            } else {\n                digester.addSetNext(pattern,\n                                    \"addRealm\",\n                                    \"org.apache.catalina.Realm\");\n            }\n        }\n    }"}
{"idx": 467, "target": 0, "func": "private void deploy() {\n\n        if (host.getLogger().isDebugEnabled())\n            host.getLogger().debug(sm.getString(\"userConfig.deploying\"));\n\n        // Load the user database object for this host\n        UserDatabase database = null;\n        try {\n            Class<?> clazz = Class.forName(userClass);\n            database = (UserDatabase) clazz.newInstance();\n            database.setUserConfig(this);\n        } catch (Exception e) {\n            host.getLogger().error(sm.getString(\"userConfig.database\"), e);\n            return;\n        }\n\n        ExecutorService executor = host.getStartStopExecutor();\n        List<Future<?>> results = new ArrayList<>();\n\n        // Deploy the web application (if any) for each defined user\n        Enumeration<String> users = database.getUsers();\n        while (users.hasMoreElements()) {\n            String user = users.nextElement();\n            if (!isDeployAllowed(user)) continue;\n            String home = database.getHome(user);\n            results.add(executor.submit(new DeployUserDirectory(this, user, home)));\n        }\n\n        for (Future<?> result : results) {\n            try {\n                result.get();\n            } catch (Exception e) {\n                host.getLogger().error(sm.getString(\"userConfig.deploy.threaded.error\"), e);\n            }\n        }\n    }"}
{"idx": 468, "target": 0, "func": "protected static void addResource(Context context, Resource annotation) {\n        addResource(context, annotation, null, null);\n    }"}
{"idx": 469, "target": 1, "func": "void parseConfigFile(LinkedHashSet<String> servicesFound, URL url)\n            throws IOException {\n        try (InputStream is = url.openStream()) {\n            InputStreamReader in =\n                    new InputStreamReader(is, StandardCharsets.UTF_8);\n            BufferedReader reader = new BufferedReader(in);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                int i = line.indexOf('#');\n                if (i >= 0) {\n                    line = line.substring(0, i);\n                }\n                line = line.trim();\n                if (line.length() == 0) {\n                    continue;\n                }\n                servicesFound.add(line);\n            }\n        }\n    }"}
{"idx": 470, "target": 0, "func": "@Override\n    public void storeChildren(PrintWriter aWriter, int indent, Object aEngine,\n            StoreDescription parentDesc) throws Exception {\n        if (aEngine instanceof StandardEngine) {\n            StandardEngine engine = (StandardEngine) aEngine;\n            // Store nested <Listener> elements\n            LifecycleListener listeners[] = ((Lifecycle) engine)\n                    .findLifecycleListeners();\n            storeElementArray(aWriter, indent, listeners);\n\n            // Store nested <Realm> element\n            Realm realm = engine.getRealm();\n            if (realm != null) {\n                Realm parentRealm = null;\n                // TODO is this case possible? (see it a old Server 5.0 impl)\n                if (engine.getParent() != null) {\n                    parentRealm = engine.getParent().getRealm();\n                }\n                if (realm != parentRealm) {\n                    storeElement(aWriter, indent, realm);\n\n                }\n            }\n\n            // Store nested <Valve> elements\n            Valve valves[] = engine.getPipeline().getValves();\n            if(valves != null && valves.length > 0 ) {\n                List<Valve> engineValves = new ArrayList<>() ;\n                for(int i = 0 ; i < valves.length ; i++ ) {\n                    if(!( valves[i] instanceof ClusterValve))\n                        engineValves.add(valves[i]);\n                }\n                storeElementArray(aWriter, indent, engineValves.toArray());\n            }\n\n            // store all <Cluster> elements\n            Cluster cluster = engine.getCluster();\n            if (cluster != null) {\n                storeElement(aWriter, indent, cluster);\n            }\n            // store all <Host> elements\n            Container children[] = engine.findChildren();\n            storeElementArray(aWriter, indent, children);\n\n       }\n    }"}
{"idx": 471, "target": 1, "func": "public long getFrequency() {\n        String p = properties.getProperty(\"mcastFrequency\");\n        return new Long(p).longValue();\n    }"}
{"idx": 472, "target": 1, "func": "public int getPort() {\n        String p = properties.getProperty(\"mcastPort\");\n        return new Integer(p).intValue();\n    }"}
{"idx": 473, "target": 1, "func": "public long getRecoverySleepTime(){\n        String p = properties.getProperty(\"recoverySleepTime\");\n        if(p != null){\n            return new Long(p).longValue();\n        }\n        return -1;\n    }"}
{"idx": 474, "target": 1, "func": "public long getDropTime() {\n        String p = properties.getProperty(\"memberDropTime\");\n        return new Long(p).longValue();\n    }"}
{"idx": 475, "target": 1, "func": "public int getRecoveryCounter(){\n        String p = properties.getProperty(\"recoveryCounter\");\n        if(p != null){\n            return new Integer(p).intValue();\n        }\n        return -1;\n    }"}
{"idx": 476, "target": 0, "func": "public byte[] getPayload() {\n        return payload;\n    }"}
{"idx": 477, "target": 0, "func": "public byte[] getDomain() {\n        return domain;\n    }"}
{"idx": 478, "target": 0, "func": "@Override\n    public void setPayload(byte[] payload) {\n        this.payload = payload;\n        if ( localMember != null ) {\n            localMember.setPayload(payload);\n            localMember.getData(true,true);\n            try {\n                if (impl != null) impl.send(false);\n            }catch ( Exception x ) {\n                log.error(sm.getString(\"McastService.payload\"), x);\n            }\n        }\n    }"}
{"idx": 479, "target": 0, "func": "@Override\n    public void setDomain(byte[] domain) {\n        this.domain = domain;\n        if ( localMember != null ) {\n            localMember.setDomain(domain);\n            localMember.getData(true,true);\n            try {\n                if (impl != null) impl.send(false);\n            }catch ( Exception x ) {\n                log.error(sm.getString(\"McastService.domain\"), x);\n            }\n        }\n    }"}
{"idx": 480, "target": 0, "func": "public synchronized boolean stop(int level) throws IOException {\n        boolean valid = false;\n\n        if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {\n            valid = true;\n            doRunReceiver = false;\n            if ( receiver !=null ) receiver.interrupt();\n            receiver = null;\n        }\n        if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {\n            valid = true;\n            doRunSender = false;\n            if ( sender != null )sender.interrupt();\n            sender = null;\n        }\n\n        if (!valid) {\n            throw new IllegalArgumentException(\"Invalid stop level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ\");\n        }\n        startLevel = (startLevel & (~level));\n        //we're shutting down, send a shutdown message and close the socket\n        if ( startLevel == 0 ) {\n            //send a stop message\n            member.setCommand(Member.SHUTDOWN_PAYLOAD);\n            member.getData(true, true);\n            send(false);\n            //leave mcast group\n            try {socket.leaveGroup(address);}catch ( Exception ignore){}\n            try {socket.close();}catch ( Exception ignore){}\n            member.setServiceStartTime(-1);\n        }\n        return (startLevel == 0);\n    }"}
{"idx": 481, "target": 0, "func": "@Override\n                public void run() {\n                    String name = Thread.currentThread().getName();\n                    try {\n                        Thread.currentThread().setName(\"Membership-MemberDisappeared.\");\n                        service.memberDisappeared(m);\n                    }finally {\n                        Thread.currentThread().setName(name);\n                    }\n                }"}
{"idx": 482, "target": 0, "func": "@Override\n                public void run() {\n                    String name = Thread.currentThread().getName();\n                    try {\n                        Thread.currentThread().setName(\"Membership-MemberDisappeared.\");\n                        service.memberDisappeared(m);\n                    }finally {\n                        Thread.currentThread().setName(name);\n                    }\n                }"}
{"idx": 483, "target": 0, "func": "@Override\n                public void run() {\n                    String name = Thread.currentThread().getName();\n                    try {\n                        Thread.currentThread().setName(\"Membership-MemberDisappeared.\");\n                        service.memberDisappeared(m);\n                    }finally {\n                        Thread.currentThread().setName(name);\n                    }\n                }"}
{"idx": 484, "target": 1, "func": "public void mapMemberAdded(Member member) {\n        if ( member.equals(getChannel().getLocalMember(false)) ) return;\n        boolean memberAdded = false;\n        //select a backup node if we don't have one\n        synchronized (mapMembers) {\n            if (!mapMembers.containsKey(member) ) {\n                mapMembers.put(member, new Long(System.currentTimeMillis()));\n                memberAdded = true;\n            }\n        }\n        if ( memberAdded ) {\n            synchronized (stateMutex) {\n                Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();\n                while (i.hasNext()) {\n                    Map.Entry<K,MapEntry<K,V>> e = i.next();\n                    MapEntry<K,V> entry = innerMap.get(e.getKey());\n                    if ( entry == null ) continue;\n                    if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {\n                        try {\n                            Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());\n                            entry.setBackupNodes(backup);\n                            entry.setPrimary(channel.getLocalMember(false));\n                        } catch (ChannelException x) {\n                            log.error(\"Unable to select backup node.\", x);\n                        } //catch\n                    } //end if\n                } //while\n            } //synchronized\n        }//end if\n    }"}
{"idx": 485, "target": 1, "func": "protected void memberAlive(Member member) {\n        synchronized (mapMembers) {\n            if (!mapMembers.containsKey(member)) {\n                mapMemberAdded(member);\n            } //end if\n            mapMembers.put(member, new Long(System.currentTimeMillis()));\n        }\n    }"}
{"idx": 486, "target": 0, "func": "public byte[] getMapContextName() {\n        return mapContextName;\n    }"}
{"idx": 487, "target": 0, "func": "public ClassLoader[] getExternalLoaders() {\n        return externalLoaders;\n    }"}
{"idx": 488, "target": 0, "func": "public void setExternalLoaders(ClassLoader[] externalLoaders) {\n        this.externalLoaders = externalLoaders;\n    }"}
{"idx": 489, "target": 1, "func": "protected void closeSocket() {\n        if(isConnected()) {\n             if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException x) {\n                    // Ignore\n                } finally {\n                    socket = null;\n                    soOut = null;\n                    soIn = null;\n                }\n            }\n            setRequestCount(0);\n            setConnected(false);\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"IDataSender.closeSocket\",getAddress().getHostAddress(), new Integer(getPort()),new Long(0)));\n       }\n    }"}
{"idx": 490, "target": 1, "func": "protected void closeSocket() {\n        if(isConnected()) {\n             if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException x) {\n                    // Ignore\n                } finally {\n                    socket = null;\n                    soOut = null;\n                    soIn = null;\n                }\n            }\n            setRequestCount(0);\n            setConnected(false);\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"IDataSender.closeSocket\",getAddress().getHostAddress(), new Integer(getPort()),new Long(0)));\n       }\n    }"}
{"idx": 491, "target": 1, "func": "@Override\n    public  void disconnect() {\n        boolean connect = isConnected();\n        closeSocket();\n        if (connect) {\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"IDataSender.disconnect\", getAddress().getHostAddress(), new Integer(getPort()), new Long(0)));\n        }\n\n    }"}
{"idx": 492, "target": 1, "func": "@Override\n    public  void disconnect() {\n        boolean connect = isConnected();\n        closeSocket();\n        if (connect) {\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"IDataSender.disconnect\", getAddress().getHostAddress(), new Integer(getPort()), new Long(0)));\n        }\n\n    }"}
{"idx": 493, "target": 1, "func": "protected void openSocket() throws IOException {\n       if(isConnected()) return ;\n       try {\n           socket = new Socket();\n           InetSocketAddress sockaddr = new InetSocketAddress(getAddress(), getPort());\n           socket.connect(sockaddr,(int)getTimeout());\n           socket.setSendBufferSize(getTxBufSize());\n           socket.setReceiveBufferSize(getRxBufSize());\n           socket.setSoTimeout( (int) getTimeout());\n           socket.setTcpNoDelay(getTcpNoDelay());\n           socket.setKeepAlive(getSoKeepAlive());\n           socket.setReuseAddress(getSoReuseAddress());\n           socket.setOOBInline(getOoBInline());\n           socket.setSoLinger(getSoLingerOn(),getSoLingerTime());\n           socket.setTrafficClass(getSoTrafficClass());\n           setConnected(true);\n           soOut = socket.getOutputStream();\n           soIn  = socket.getInputStream();\n           setRequestCount(0);\n           setConnectTime(System.currentTimeMillis());\n           if (log.isDebugEnabled())\n               log.debug(sm.getString(\"IDataSender.openSocket\", getAddress().getHostAddress(), new Integer(getPort()), new Long(0)));\n      } catch (IOException ex1) {\n          SenderState.getSenderState(getDestination()).setSuspect();\n          if (log.isDebugEnabled())\n              log.debug(sm.getString(\"IDataSender.openSocket.failure\",getAddress().getHostAddress(), new Integer(getPort()),new Long(0)), ex1);\n          throw (ex1);\n        }\n\n     }"}
{"idx": 494, "target": 1, "func": "protected void openSocket() throws IOException {\n       if(isConnected()) return ;\n       try {\n           socket = new Socket();\n           InetSocketAddress sockaddr = new InetSocketAddress(getAddress(), getPort());\n           socket.connect(sockaddr,(int)getTimeout());\n           socket.setSendBufferSize(getTxBufSize());\n           socket.setReceiveBufferSize(getRxBufSize());\n           socket.setSoTimeout( (int) getTimeout());\n           socket.setTcpNoDelay(getTcpNoDelay());\n           socket.setKeepAlive(getSoKeepAlive());\n           socket.setReuseAddress(getSoReuseAddress());\n           socket.setOOBInline(getOoBInline());\n           socket.setSoLinger(getSoLingerOn(),getSoLingerTime());\n           socket.setTrafficClass(getSoTrafficClass());\n           setConnected(true);\n           soOut = socket.getOutputStream();\n           soIn  = socket.getInputStream();\n           setRequestCount(0);\n           setConnectTime(System.currentTimeMillis());\n           if (log.isDebugEnabled())\n               log.debug(sm.getString(\"IDataSender.openSocket\", getAddress().getHostAddress(), new Integer(getPort()), new Long(0)));\n      } catch (IOException ex1) {\n          SenderState.getSenderState(getDestination()).setSuspect();\n          if (log.isDebugEnabled())\n              log.debug(sm.getString(\"IDataSender.openSocket.failure\",getAddress().getHostAddress(), new Integer(getPort()),new Long(0)), ex1);\n          throw (ex1);\n        }\n\n     }"}
{"idx": 495, "target": 1, "func": "public  void sendMessage(byte[] data, boolean waitForAck) throws IOException {\n        IOException exception = null;\n        setAttempt(0);\n        try {\n             // first try with existing connection\n             pushMessage(data,false,waitForAck);\n        } catch (IOException x) {\n            SenderState.getSenderState(getDestination()).setSuspect();\n            exception = x;\n            if (log.isTraceEnabled()) log.trace(sm.getString(\"IDataSender.send.again\", getAddress().getHostAddress(),new Integer(getPort())),x);\n            while ( getAttempt()<getMaxRetryAttempts() ) {\n                try {\n                    setAttempt(getAttempt()+1);\n                    // second try with fresh connection\n                    pushMessage(data, true,waitForAck);\n                    exception = null;\n                } catch (IOException xx) {\n                    exception = xx;\n                    closeSocket();\n                }\n            }\n        } finally {\n            setRequestCount(getRequestCount()+1);\n            keepalive();\n            if ( exception != null ) throw exception;\n        }\n    }"}
{"idx": 496, "target": 1, "func": "protected void waitForAck() throws java.io.IOException {\n        try {\n            boolean ackReceived = false;\n            boolean failAckReceived = false;\n            ackbuf.clear();\n            int bytesRead = 0;\n            int i = soIn.read();\n            while ((i != -1) && (bytesRead < Constants.ACK_COMMAND.length)) {\n                bytesRead++;\n                byte d = (byte)i;\n                ackbuf.append(d);\n                if (ackbuf.doesPackageExist() ) {\n                    byte[] ackcmd = ackbuf.extractDataPackage(true).getBytes();\n                    ackReceived = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.ACK_DATA);\n                    failAckReceived = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA);\n                    ackReceived = ackReceived || failAckReceived;\n                    break;\n                }\n                i = soIn.read();\n            }\n            if (!ackReceived) {\n                if (i == -1) throw new IOException(sm.getString(\"IDataSender.ack.eof\",getAddress(), new Integer(socket.getLocalPort())));\n                else throw new IOException(sm.getString(\"IDataSender.ack.wrong\",getAddress(), new Integer(socket.getLocalPort())));\n            } else if ( failAckReceived && getThrowOnFailedAck()) {\n                throw new RemoteProcessException(\"Received a failed ack:org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA\");\n            }\n        } catch (IOException x) {\n            String errmsg = sm.getString(\"IDataSender.ack.missing\", getAddress(),new Integer(socket.getLocalPort()), new Long(getTimeout()));\n            if ( SenderState.getSenderState(getDestination()).isReady() ) {\n                SenderState.getSenderState(getDestination()).setSuspect();\n                if ( log.isWarnEnabled() ) log.warn(errmsg, x);\n            } else {\n                if ( log.isDebugEnabled() )log.debug(errmsg, x);\n            }\n            throw x;\n        } finally {\n            ackbuf.clear();\n        }\n    }"}
{"idx": 497, "target": 0, "func": "@Override\n    public synchronized void disconnect() {\n        try {close(); }catch (Exception x){/* Ignore */}\n        setConnected(false);\n    }"}
{"idx": 498, "target": 0, "func": "@Override\n    public void finalize() {\n        try {disconnect(); }catch ( Exception e){/* Ignore */}\n    }"}
{"idx": 499, "target": 0, "func": "@Override\n    public void finalize() {\n        try {disconnect(); }catch ( Exception e){/* Ignore */}\n    }"}
{"idx": 500, "target": 0, "func": "protected BioSender[] setupForSend(Member[] destination) throws ChannelException {\n        ChannelException cx = null;\n        BioSender[] result = new BioSender[destination.length];\n        for ( int i=0; i<destination.length; i++ ) {\n            try {\n                BioSender sender = bioSenders.get(destination[i]);\n                if (sender == null) {\n                    sender = new BioSender();\n                    AbstractSender.transferProperties(this,sender);\n                    sender.setDestination(destination[i]);\n                    bioSenders.put(destination[i], sender);\n                }\n                result[i] = sender;\n                if (!result[i].isConnected() ) result[i].connect();\n                result[i].keepalive();\n            }catch (Exception x ) {\n                if ( cx== null ) cx = new ChannelException(x);\n                cx.addFaultyMember(destination[i],x);\n            }\n        }\n        if ( cx!=null ) throw cx;\n        else return result;\n    }"}
{"idx": 501, "target": 0, "func": "public byte[] getKey() {\n        return key;\n    }"}
{"idx": 502, "target": 0, "func": "public Member[] getDestination() {\n        return destination;\n    }"}
{"idx": 503, "target": 0, "func": "protected void stopListening() {\n        setListen(false);\n        Selector selector = this.selector.get();\n        if (selector != null) {\n            try {\n                // Unlock the thread if is is blocked waiting for input\n                selector.wakeup();\n                // Wait for the receiver thread to finish\n                int count = 0;\n                while (running && count < 50) {\n                    Thread.sleep(100);\n                    count ++;\n                }\n                if (running) {\n                    log.warn(sm.getString(\"NioReceiver.stop.threadRunning\"));\n                }\n                closeSelector();\n            } catch (Exception x) {\n                log.error(sm.getString(\"NioReceiver.stop.fail\"), x);\n            } finally {\n                this.selector.set(null);\n            }\n        }\n    }"}
{"idx": 504, "target": 0, "func": "@Override\n    public synchronized void disconnect() {\n        setConnected(false);\n        try {close(); }catch (Exception x){/*Ignore*/}\n    }"}
{"idx": 505, "target": 0, "func": "@Override\n    public void finalize() {\n        try {disconnect(); }catch ( Exception e){/*Ignore*/}\n        try {\n            selector.close();\n        }catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Failed to close selector\", e);\n            }\n        }\n    }"}
{"idx": 506, "target": 1, "func": "private static void addFolderList(String property) {\n\n        // get the files in the extensions directory\n        String extensionsDir = System.getProperty(property);\n        if (extensionsDir != null) {\n            StringTokenizer extensionsTok\n                = new StringTokenizer(extensionsDir, File.pathSeparator);\n            while (extensionsTok.hasMoreTokens()) {\n                File targetDir = new File(extensionsTok.nextToken());\n                if (!targetDir.isDirectory()) {\n                    continue;\n                }\n                File[] files = targetDir.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    if (files[i].getName().toLowerCase(Locale.ENGLISH).endsWith(\".jar\") &&\n                            files[i].isFile()) {\n                        try {\n                            addSystemResource(files[i]);\n                        } catch (IOException e) {\n                            log.error\n                                (sm.getString\n                                 (\"extensionValidator.failload\", files[i]), e);\n                        }\n                    }\n                }\n            }\n        }\n\n    }"}
{"idx": 507, "target": 0, "func": "@Override\n    public LifecycleState getState() {\n        return state;\n    }"}
{"idx": 508, "target": 0, "func": "public String encode( String path ) {\n        int maxBytesPerChar = 10;\n        StringBuilder rewrittenPath = new StringBuilder(path.length());\n        ByteArrayOutputStream buf = new ByteArrayOutputStream(maxBytesPerChar);\n        OutputStreamWriter writer = null;\n        try {\n            writer = new OutputStreamWriter(buf, \"UTF8\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            writer = new OutputStreamWriter(buf);\n        }\n\n        for (int i = 0; i < path.length(); i++) {\n            int c = path.charAt(i);\n            if (safeCharacters.get(c)) {\n                rewrittenPath.append((char)c);\n            } else {\n                // convert to external encoding before hex conversion\n                try {\n                    writer.write((char)c);\n                    writer.flush();\n                } catch(IOException e) {\n                    buf.reset();\n                    continue;\n                }\n                byte[] ba = buf.toByteArray();\n                for (int j = 0; j < ba.length; j++) {\n                    // Converting each byte in the buffer\n                    byte toEncode = ba[j];\n                    rewrittenPath.append('%');\n                    int low = toEncode & 0x0f;\n                    int high = (toEncode & 0xf0) >> 4;\n                    rewrittenPath.append(hexadecimal[high]);\n                    rewrittenPath.append(hexadecimal[low]);\n                }\n                buf.reset();\n            }\n        }\n        return rewrittenPath.toString();\n    }"}
{"idx": 509, "target": 1, "func": "@Override\n    public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        if (!getEnabled() || rules == null || rules.length == 0) {\n            getNext().invoke(request, response);\n            return;\n        }\n\n        if (invoked.get() == Boolean.TRUE) {\n            try {\n                getNext().invoke(request, response);\n            } finally {\n                invoked.set(null);\n            }\n            return;\n        }\n\n        try {\n\n            Resolver resolver = new ResolverImpl(request);\n\n            invoked.set(Boolean.TRUE);\n\n            // As long as MB isn't a char sequence or affiliated, this has to be\n            // converted to a string\n            MessageBytes urlMB = context ? request.getRequestPathMB() : request.getDecodedRequestURIMB();\n            urlMB.toChars();\n            CharSequence url = urlMB.getCharChunk();\n            CharSequence host = request.getServerName();\n            boolean rewritten = false;\n            boolean done = false;\n            for (int i = 0; i < rules.length; i++) {\n                RewriteRule rule = rules[i];\n                CharSequence test = (rule.isHost()) ? host : url;\n                CharSequence newtest = rule.evaluate(test, resolver);\n                if (newtest != null && !test.equals(newtest.toString())) {\n                    if (container.getLogger().isDebugEnabled()) {\n                        container.getLogger().debug(\"Rewrote \" + test + \" as \" + newtest\n                                + \" with rule pattern \" + rule.getPatternString());\n                    }\n                    if (rule.isHost()) {\n                        host = newtest;\n                    } else {\n                        url = newtest;\n                    }\n                    rewritten = true;\n                }\n\n                // Final reply\n\n                // - forbidden\n                if (rule.isForbidden() && newtest != null) {\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                    done = true;\n                    break;\n                }\n                // - gone\n                if (rule.isGone() && newtest != null) {\n                    response.sendError(HttpServletResponse.SC_GONE);\n                    done = true;\n                    break;\n                }\n                // - redirect (code)\n                if (rule.isRedirect() && newtest != null) {\n                    // append the query string to the url if there is one and it hasn't been rewritten\n                    String queryString = request.getQueryString();\n                    StringBuffer urlString = new StringBuffer(url);\n                    if (queryString != null && queryString.length() > 0) {\n                        int index = urlString.indexOf(\"?\");\n                        if (index != -1) {\n                            // if qsa is specified append the query\n                            if (rule.isQsappend()) {\n                                urlString.append('&');\n                                urlString.append(queryString);\n                            }\n                            // if the ? is the last character delete it, its only purpose was to\n                            // prevent the rewrite module from appending the query string\n                            else if (index == urlString.length() - 1) {\n                                urlString.deleteCharAt(index);\n                            }\n                        } else {\n                            urlString.append('?');\n                            urlString.append(queryString);\n                        }\n                    }\n                    // Insert the context if\n                    // 1. this valve is associated with a context\n                    // 2. the url starts with a leading slash\n                    // 3. the url isn't absolute\n                    if (context && urlString.charAt(0) == '/' && !hasScheme(urlString)) {\n                        urlString.insert(0, request.getContext().getEncodedPath());\n                    }\n                    response.sendRedirect(urlString.toString());\n                    response.setStatus(rule.getRedirectCode());\n                    done = true;\n                    break;\n                }\n\n                // Reply modification\n\n                // - cookie\n                if (rule.isCookie() && newtest != null) {\n                    Cookie cookie = new Cookie(rule.getCookieName(),\n                            rule.getCookieResult());\n                    cookie.setDomain(rule.getCookieDomain());\n                    cookie.setMaxAge(rule.getCookieLifetime());\n                    cookie.setPath(rule.getCookiePath());\n                    cookie.setSecure(rule.isCookieSecure());\n                    cookie.setHttpOnly(rule.isCookieHttpOnly());\n                    response.addCookie(cookie);\n                }\n                // - env (note: this sets a request attribute)\n                if (rule.isEnv() && newtest != null) {\n                    for (int j = 0; j < rule.getEnvSize(); j++) {\n                        request.setAttribute(rule.getEnvName(j), rule.getEnvResult(j));\n                    }\n                }\n                // - content type (note: this will not force the content type, use a filter\n                //   to do that)\n                if (rule.isType() && newtest != null) {\n                    request.setContentType(rule.getTypeValue());\n                }\n                // - qsappend\n                if (rule.isQsappend() && newtest != null) {\n                    String queryString = request.getQueryString();\n                    String urlString = url.toString();\n                    if (urlString.indexOf('?') != -1 && queryString != null) {\n                        url = urlString + \"&\" + queryString;\n                    }\n                }\n\n                // Control flow processing\n\n                // - chain (skip remaining chained rules if this one does not match)\n                if (rule.isChain() && newtest == null) {\n                    for (int j = i; j < rules.length; j++) {\n                        if (!rules[j].isChain()) {\n                            i = j;\n                            break;\n                        }\n                    }\n                    continue;\n                }\n                // - last (stop rewriting here)\n                if (rule.isLast() && newtest != null) {\n                    break;\n                }\n                // - next (redo again)\n                if (rule.isNext() && newtest != null) {\n                    i = 0;\n                    continue;\n                }\n                // - skip (n rules)\n                if (newtest != null) {\n                    i += rule.getSkip();\n                }\n\n            }\n\n            if (rewritten) {\n                if (!done) {\n                    // See if we need to replace the query string\n                    String urlString = url.toString();\n                    String queryString = null;\n                    int queryIndex = urlString.indexOf('?');\n                    if (queryIndex != -1) {\n                        queryString = urlString.substring(queryIndex+1);\n                        urlString = urlString.substring(0, queryIndex);\n                    }\n                    // Set the new URL\n                    request.getCoyoteRequest().requestURI().setString(null);\n                    CharChunk chunk = request.getCoyoteRequest().requestURI().getCharChunk();\n                    chunk.recycle();\n                    if (context) {\n                        chunk.append(request.getContextPath());\n                    }\n                    chunk.append(urlString);\n                    request.getCoyoteRequest().requestURI().toChars();\n                    // Set the new Query if there is one\n                    if (queryString != null) {\n                        request.getCoyoteRequest().queryString().setString(null);\n                        chunk = request.getCoyoteRequest().queryString().getCharChunk();\n                        chunk.recycle();\n                        chunk.append(queryString);\n                        request.getCoyoteRequest().queryString().toChars();\n                    }\n                    // Set the new host if it changed\n                    if (!host.equals(request.getServerName())) {\n                        request.getCoyoteRequest().serverName().setString(null);\n                        chunk = request.getCoyoteRequest().serverName().getCharChunk();\n                        chunk.recycle();\n                        chunk.append(host.toString());\n                        request.getCoyoteRequest().serverName().toChars();\n                    }\n                    request.getMappingData().recycle();\n                    // Reinvoke the whole request recursively\n                    try {\n                        request.getConnector().getProtocolHandler().getAdapter().service\n                        (request.getCoyoteRequest(), response.getCoyoteResponse());\n                    } catch (Exception e) {\n                        // This doesn't actually happen in the Catalina adapter implementation\n                    }\n                }\n            } else {\n                getNext().invoke(request, response);\n            }\n\n        } finally {\n            invoked.set(null);\n        }\n\n    }"}
{"idx": 510, "target": 0, "func": "protected void parse(BufferedReader reader) throws LifecycleException {\n        ArrayList<RewriteRule> rules = new ArrayList<>();\n        ArrayList<RewriteCond> conditions = new ArrayList<>();\n        while (true) {\n            try {\n                String line = reader.readLine();\n                if (line == null) {\n                    break;\n                }\n                Object result = parse(line);\n                if (result instanceof RewriteRule) {\n                    RewriteRule rule = (RewriteRule) result;\n                    if (container.getLogger().isDebugEnabled()) {\n                        container.getLogger().debug(\"Add rule with pattern \" + rule.getPatternString()\n                                + \" and substitution \" + rule.getSubstitutionString());\n                    }\n                    for (int i = (conditions.size() - 1); i > 0; i--) {\n                        if (conditions.get(i - 1).isOrnext()) {\n                            conditions.get(i).setOrnext(true);\n                        }\n                    }\n                    for (int i = 0; i < conditions.size(); i++) {\n                        if (container.getLogger().isDebugEnabled()) {\n                            RewriteCond cond = conditions.get(i);\n                            container.getLogger().debug(\"Add condition \" + cond.getCondPattern()\n                                    + \" test \" + cond.getTestString() + \" to rule with pattern \"\n                                    + rule.getPatternString() + \" and substitution \"\n                                    + rule.getSubstitutionString() + (cond.isOrnext() ? \" [OR]\" : \"\")\n                                    + (cond.isNocase() ? \" [NC]\" : \"\"));\n                        }\n                        rule.addCondition(conditions.get(i));\n                    }\n                    conditions.clear();\n                    rules.add(rule);\n                } else if (result instanceof RewriteCond) {\n                    conditions.add((RewriteCond) result);\n                } else if (result instanceof Object[]) {\n                    String mapName = (String) ((Object[]) result)[0];\n                    RewriteMap map = (RewriteMap) ((Object[]) result)[1];\n                    maps.put(mapName, map);\n                    if (map instanceof Lifecycle) {\n                        ((Lifecycle) map).start();\n                    }\n                }\n            } catch (IOException e) {\n                container.getLogger().error(\"Error reading configuration\", e);\n            }\n        }\n        this.rules = rules.toArray(new RewriteRule[0]);\n\n        // Finish parsing the rules\n        for (int i = 0; i < this.rules.length; i++) {\n            this.rules[i].parse(maps);\n        }\n    }"}
{"idx": 511, "target": 1, "func": "public Optional noneMatch(LambdaExpression le) {\n        if (!iterator.hasNext()) {\n            return Optional.EMPTY;\n        }\n\n        Boolean match = Boolean.FALSE;\n\n        while (!match.booleanValue() && iterator.hasNext()) {\n            match = (Boolean) le.invoke(iterator.next());\n        }\n\n        return new Optional(new Boolean(!match.booleanValue()));\n    }"}
{"idx": 512, "target": 0, "func": "@Override\n        public Object next() {\n            return Array.get(base, index++);\n        }"}
{"idx": 513, "target": 1, "func": "public static String get(final String key) {\n        return bundle.getString(key);\n    }"}
{"idx": 514, "target": 1, "func": "protected ClassLoader initClassLoader() throws IOException {\n\n        classPath = getClassPath();\n\n        ClassLoader jspcLoader = getClass().getClassLoader();\n        if (jspcLoader instanceof AntClassLoader) {\n            classPath += File.pathSeparator\n                + ((AntClassLoader) jspcLoader).getClasspath();\n        }\n\n        // Turn the classPath into URLs\n        ArrayList<URL> urls = new ArrayList<>();\n        StringTokenizer tokenizer = new StringTokenizer(classPath,\n                                                        File.pathSeparator);\n        while (tokenizer.hasMoreTokens()) {\n            String path = tokenizer.nextToken();\n            try {\n                File libFile = new File(path);\n                urls.add(libFile.toURI().toURL());\n            } catch (IOException ioe) {\n                // Failing a toCanonicalPath on a file that\n                // exists() should be a JVM regression test,\n                // therefore we have permission to freak uot\n                throw new RuntimeException(ioe.toString());\n            }\n        }\n\n        File webappBase = new File(uriRoot);\n        if (webappBase.exists()) {\n            File classes = new File(webappBase, \"/WEB-INF/classes\");\n            try {\n                if (classes.exists()) {\n                    classPath = classPath + File.pathSeparator\n                        + classes.getCanonicalPath();\n                    urls.add(classes.getCanonicalFile().toURI().toURL());\n                }\n            } catch (IOException ioe) {\n                // failing a toCanonicalPath on a file that\n                // exists() should be a JVM regression test,\n                // therefore we have permission to freak out\n                throw new RuntimeException(ioe.toString());\n            }\n            File lib = new File(webappBase, \"/WEB-INF/lib\");\n            if (lib.exists() && lib.isDirectory()) {\n                String[] libs = lib.list();\n                for (int i = 0; i < libs.length; i++) {\n                    if( libs[i].length() <5 ) continue;\n                    String ext=libs[i].substring( libs[i].length() - 4 );\n                    if (! \".jar\".equalsIgnoreCase(ext)) {\n                        if (\".tld\".equalsIgnoreCase(ext)) {\n                            log.warn(\"TLD files should not be placed in \"\n                                     + \"/WEB-INF/lib\");\n                        }\n                        continue;\n                    }\n                    try {\n                        File libFile = new File(lib, libs[i]);\n                        classPath = classPath + File.pathSeparator\n                            + libFile.getAbsolutePath();\n                        urls.add(libFile.getAbsoluteFile().toURI().toURL());\n                    } catch (IOException ioe) {\n                        // failing a toCanonicalPath on a file that\n                        // exists() should be a JVM regression test,\n                        // therefore we have permission to freak out\n                        throw new RuntimeException(ioe.toString());\n                    }\n                }\n            }\n        }\n\n        URL urlsA[]=new URL[urls.size()];\n        urls.toArray(urlsA);\n        loader = new URLClassLoader(urlsA, this.getClass().getClassLoader());\n        return loader;\n    }"}
{"idx": 515, "target": 0, "func": "public ClassLoader getJspLoader() {\n        if( jspLoader == null ) {\n            jspLoader = new JasperLoader\n                    (new URL[] {baseUrl},\n                            getClassLoader(),\n                            rctxt.getPermissionCollection());\n        }\n        return jspLoader;\n    }"}
{"idx": 516, "target": 1, "func": "@Override\n        public String toString() {\n            return \"\";\n        }"}
{"idx": 517, "target": 0, "func": "public static void generate(ServletWriter out, Compiler compiler,\n            Node.Nodes page) throws JasperException {\n\n        Generator gen = new Generator(out, compiler);\n\n        if (gen.isPoolingEnabled) {\n            gen.compileTagHandlerPoolList(page);\n        }\n        gen.generateCommentHeader();\n        if (gen.ctxt.isTagFile()) {\n            JasperTagInfo tagInfo = (JasperTagInfo) gen.ctxt.getTagInfo();\n            gen.generateTagHandlerPreamble(tagInfo, page);\n\n            if (gen.ctxt.isPrototypeMode()) {\n                return;\n            }\n\n            gen.generateXmlProlog(page);\n            gen.fragmentHelperClass.generatePreamble();\n            page.visit(gen.new GenerateVisitor(gen.ctxt.isTagFile(), out,\n                    gen.methodsBuffered, gen.fragmentHelperClass));\n            gen.generateTagHandlerPostamble(tagInfo);\n        } else {\n            gen.generatePreamble(page);\n            gen.generateXmlProlog(page);\n            gen.fragmentHelperClass.generatePreamble();\n            page.visit(gen.new GenerateVisitor(gen.ctxt.isTagFile(), out,\n                    gen.methodsBuffered, gen.fragmentHelperClass));\n            gen.generatePostamble();\n        }\n    }"}
{"idx": 518, "target": 1, "func": "@Override\n                public NameEnvironmentAnswer\n                    findType(char[][] compoundTypeName) {\n                    String result = \"\";\n                    String sep = \"\";\n                    for (int i = 0; i < compoundTypeName.length; i++) {\n                        result += sep;\n                        result += new String(compoundTypeName[i]);\n                        sep = \".\";\n                    }\n                    return findType(result);\n                }"}
{"idx": 519, "target": 1, "func": "private boolean isPackage(String result) {\n                    if (result.equals(targetClassName)) {\n                        return false;\n                    }\n                    String resourceName = result.replace('.', '/') + \".class\";\n                    InputStream is =\n                        classLoader.getResourceAsStream(resourceName);\n                    return is == null;\n                }"}
{"idx": 520, "target": 1, "func": "@Override\n                public void acceptResult(CompilationResult result) {\n                    try {\n                        if (result.hasProblems()) {\n                            IProblem[] problems = result.getProblems();\n                            for (int i = 0; i < problems.length; i++) {\n                                IProblem problem = problems[i];\n                                if (problem.isError()) {\n                                    String name =\n                                        new String(problems[i].getOriginatingFileName());\n                                    try {\n                                        problemList.add(ErrorDispatcher.createJavacError\n                                                (name, pageNodes, new StringBuilder(problem.getMessage()),\n                                                        problem.getSourceLineNumber(), ctxt));\n                                    } catch (JasperException e) {\n                                        log.error(\"Error visiting node\", e);\n                                    }\n                                }\n                            }\n                        }\n                        if (problemList.isEmpty()) {\n                            ClassFile[] classFiles = result.getClassFiles();\n                            for (int i = 0; i < classFiles.length; i++) {\n                                ClassFile classFile = classFiles[i];\n                                char[][] compoundName =\n                                    classFile.getCompoundName();\n                                String className = \"\";\n                                String sep = \"\";\n                                for (int j = 0;\n                                     j < compoundName.length; j++) {\n                                    className += sep;\n                                    className += new String(compoundName[j]);\n                                    sep = \".\";\n                                }\n                                byte[] bytes = classFile.getBytes();\n                                String outFile = outputDir + \"/\" +\n                                    className.replace('.', '/') + \".class\";\n                                FileOutputStream fout =\n                                    new FileOutputStream(outFile);\n                                BufferedOutputStream bos =\n                                    new BufferedOutputStream(fout);\n                                bos.write(bytes);\n                                bos.close();\n                            }\n                        }\n                    } catch (IOException exc) {\n                        log.error(\"Compilation error\", exc);\n                    }\n                }"}
{"idx": 521, "target": 0, "func": "private String[] readFile(InputStream s) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(s));\n        List<String> lines = new ArrayList<>();\n        String line;\n\n        while ( (line = reader.readLine()) != null ) {\n            lines.add(line);\n        }\n\n        return lines.toArray( new String[lines.size()] );\n    }"}
{"idx": 522, "target": 0, "func": "@SuppressWarnings(\"null\") // NPE not possible\n    private JspPropertyGroup selectProperty(JspPropertyGroup prev,\n            JspPropertyGroup curr) {\n        if (prev == null) {\n            return curr;\n        }\n        if (prev.getExtension() == null) {\n            // exact match\n            return prev;\n        }\n        if (curr.getExtension() == null) {\n            // exact match\n            return curr;\n        }\n        String prevPath = prev.getPath();\n        String currPath = curr.getPath();\n        if (prevPath == null && currPath == null) {\n            // Both specifies a *.ext, keep the first one\n            return prev;\n        }\n        if (prevPath == null && currPath != null) {\n            return curr;\n        }\n        if (prevPath != null && currPath == null) {\n            return prev;\n        }\n        if (prevPath.length() >= currPath.length()) {\n            return prev;\n        }\n        return curr;\n    }"}
{"idx": 523, "target": 0, "func": "private void processChars() throws SAXException {\n\n        if (charBuffer == null || directivesOnly) {\n            return;\n        }\n\n        /*\n         * JSP.6.1.1: All textual nodes that have only white space are to be\n         * dropped from the document, except for nodes in a jsp:text element,\n         * and any leading and trailing white-space-only textual nodes in a\n         * jsp:attribute whose 'trim' attribute is set to FALSE, which are to\n         * be kept verbatim.\n         * JSP.6.2.3 defines white space characters.\n         */\n        boolean isAllSpace = true;\n        if (!(current instanceof Node.JspText)\n            && !(current instanceof Node.NamedAttribute)) {\n            for (int i = 0; i < charBuffer.length(); i++) {\n                char ch = charBuffer.charAt(i);\n                if (!(ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t')) {\n                    isAllSpace = false;\n                    break;\n                }\n            }\n        }\n\n        if (!isAllSpace && tagDependentPending) {\n            tagDependentPending = false;\n            tagDependentNesting++;\n        }\n\n        if (tagDependentNesting > 0 || pageInfo.isELIgnored() ||\n                current instanceof Node.ScriptingElement) {\n            if (charBuffer.length() > 0) {\n                @SuppressWarnings(\"unused\")\n                Node unused = new Node.TemplateText(\n                        charBuffer.toString(), startMark, current);\n            }\n            startMark = new Mark(ctxt, path, locator.getLineNumber(),\n                                 locator.getColumnNumber());\n            charBuffer = null;\n            return;\n        }\n\n        if ((current instanceof Node.JspText)\n            || (current instanceof Node.NamedAttribute)\n            || !isAllSpace) {\n\n            int line = startMark.getLineNumber();\n            int column = startMark.getColumnNumber();\n\n            CharArrayWriter ttext = new CharArrayWriter();\n            int lastCh = 0, elType = 0;\n            for (int i = 0; i < charBuffer.length(); i++) {\n\n                int ch = charBuffer.charAt(i);\n                if (ch == '\\n') {\n                    column = 1;\n                    line++;\n                } else {\n                    column++;\n                }\n                if ((lastCh == '$' || lastCh == '#') && ch == '{') {\n                    elType = lastCh;\n                    if (ttext.size() > 0) {\n                        @SuppressWarnings(\"unused\")\n                        Node unused = new Node.TemplateText(\n                                ttext.toString(), startMark, current);\n                        ttext.reset();\n                        //We subtract two from the column number to\n                        //account for the '[$,#]{' that we've already parsed\n                        startMark = new Mark(ctxt, path, line, column - 2);\n                    }\n                    // following \"${\" || \"#{\" to first unquoted \"}\"\n                    i++;\n                    boolean singleQ = false;\n                    boolean doubleQ = false;\n                    lastCh = 0;\n                    for (;; i++) {\n                        if (i >= charBuffer.length()) {\n                            throw new SAXParseException(\n                                Localizer.getMessage(\n                                    \"jsp.error.unterminated\",\n                                    (char) elType + \"{\"),\n                                locator);\n\n                        }\n                        ch = charBuffer.charAt(i);\n                        if (ch == '\\n') {\n                            column = 1;\n                            line++;\n                        } else {\n                            column++;\n                        }\n                        if (lastCh == '\\\\' && (singleQ || doubleQ)) {\n                            ttext.write(ch);\n                            lastCh = 0;\n                            continue;\n                        }\n                        if (ch == '}') {\n                            @SuppressWarnings(\"unused\")\n                            Node unused = new Node.ELExpression(\n                                    (char) elType, ttext.toString(),\n                                    startMark, current);\n                            ttext.reset();\n                            startMark = new Mark(ctxt, path, line, column);\n                            break;\n                        }\n                        if (ch == '\"')\n                            doubleQ = !doubleQ;\n                        else if (ch == '\\'')\n                            singleQ = !singleQ;\n\n                        ttext.write(ch);\n                        lastCh = ch;\n                    }\n                } else if (lastCh == '\\\\' && (ch == '$' || ch == '#')) {\n                    if (pageInfo.isELIgnored()) {\n                        ttext.write('\\\\');\n                    }\n                    ttext.write(ch);\n                    ch = 0;  // Not start of EL anymore\n                } else {\n                    if (lastCh == '$' || lastCh == '#' || lastCh == '\\\\') {\n                        ttext.write(lastCh);\n                    }\n                    if (ch != '$' && ch != '#' && ch != '\\\\') {\n                        ttext.write(ch);\n                    }\n                }\n                lastCh = ch;\n            }\n            if (lastCh == '$' || lastCh == '#' || lastCh == '\\\\') {\n                ttext.write(lastCh);\n            }\n            if (ttext.size() > 0) {\n                @SuppressWarnings(\"unused\")\n                Node unused = new Node.TemplateText(\n                        ttext.toString(), startMark, current);\n            }\n        }\n        startMark = new Mark(ctxt, path, locator.getLineNumber(),\n                             locator.getColumnNumber());\n\n        charBuffer = null;\n    }"}
{"idx": 524, "target": 0, "func": "private void processChars() throws SAXException {\n\n        if (charBuffer == null || directivesOnly) {\n            return;\n        }\n\n        /*\n         * JSP.6.1.1: All textual nodes that have only white space are to be\n         * dropped from the document, except for nodes in a jsp:text element,\n         * and any leading and trailing white-space-only textual nodes in a\n         * jsp:attribute whose 'trim' attribute is set to FALSE, which are to\n         * be kept verbatim.\n         * JSP.6.2.3 defines white space characters.\n         */\n        boolean isAllSpace = true;\n        if (!(current instanceof Node.JspText)\n            && !(current instanceof Node.NamedAttribute)) {\n            for (int i = 0; i < charBuffer.length(); i++) {\n                char ch = charBuffer.charAt(i);\n                if (!(ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t')) {\n                    isAllSpace = false;\n                    break;\n                }\n            }\n        }\n\n        if (!isAllSpace && tagDependentPending) {\n            tagDependentPending = false;\n            tagDependentNesting++;\n        }\n\n        if (tagDependentNesting > 0 || pageInfo.isELIgnored() ||\n                current instanceof Node.ScriptingElement) {\n            if (charBuffer.length() > 0) {\n                @SuppressWarnings(\"unused\")\n                Node unused = new Node.TemplateText(\n                        charBuffer.toString(), startMark, current);\n            }\n            startMark = new Mark(ctxt, path, locator.getLineNumber(),\n                                 locator.getColumnNumber());\n            charBuffer = null;\n            return;\n        }\n\n        if ((current instanceof Node.JspText)\n            || (current instanceof Node.NamedAttribute)\n            || !isAllSpace) {\n\n            int line = startMark.getLineNumber();\n            int column = startMark.getColumnNumber();\n\n            CharArrayWriter ttext = new CharArrayWriter();\n            int lastCh = 0, elType = 0;\n            for (int i = 0; i < charBuffer.length(); i++) {\n\n                int ch = charBuffer.charAt(i);\n                if (ch == '\\n') {\n                    column = 1;\n                    line++;\n                } else {\n                    column++;\n                }\n                if ((lastCh == '$' || lastCh == '#') && ch == '{') {\n                    elType = lastCh;\n                    if (ttext.size() > 0) {\n                        @SuppressWarnings(\"unused\")\n                        Node unused = new Node.TemplateText(\n                                ttext.toString(), startMark, current);\n                        ttext.reset();\n                        //We subtract two from the column number to\n                        //account for the '[$,#]{' that we've already parsed\n                        startMark = new Mark(ctxt, path, line, column - 2);\n                    }\n                    // following \"${\" || \"#{\" to first unquoted \"}\"\n                    i++;\n                    boolean singleQ = false;\n                    boolean doubleQ = false;\n                    lastCh = 0;\n                    for (;; i++) {\n                        if (i >= charBuffer.length()) {\n                            throw new SAXParseException(\n                                Localizer.getMessage(\n                                    \"jsp.error.unterminated\",\n                                    (char) elType + \"{\"),\n                                locator);\n\n                        }\n                        ch = charBuffer.charAt(i);\n                        if (ch == '\\n') {\n                            column = 1;\n                            line++;\n                        } else {\n                            column++;\n                        }\n                        if (lastCh == '\\\\' && (singleQ || doubleQ)) {\n                            ttext.write(ch);\n                            lastCh = 0;\n                            continue;\n                        }\n                        if (ch == '}') {\n                            @SuppressWarnings(\"unused\")\n                            Node unused = new Node.ELExpression(\n                                    (char) elType, ttext.toString(),\n                                    startMark, current);\n                            ttext.reset();\n                            startMark = new Mark(ctxt, path, line, column);\n                            break;\n                        }\n                        if (ch == '\"')\n                            doubleQ = !doubleQ;\n                        else if (ch == '\\'')\n                            singleQ = !singleQ;\n\n                        ttext.write(ch);\n                        lastCh = ch;\n                    }\n                } else if (lastCh == '\\\\' && (ch == '$' || ch == '#')) {\n                    if (pageInfo.isELIgnored()) {\n                        ttext.write('\\\\');\n                    }\n                    ttext.write(ch);\n                    ch = 0;  // Not start of EL anymore\n                } else {\n                    if (lastCh == '$' || lastCh == '#' || lastCh == '\\\\') {\n                        ttext.write(lastCh);\n                    }\n                    if (ch != '$' && ch != '#' && ch != '\\\\') {\n                        ttext.write(ch);\n                    }\n                }\n                lastCh = ch;\n            }\n            if (lastCh == '$' || lastCh == '#' || lastCh == '\\\\') {\n                ttext.write(lastCh);\n            }\n            if (ttext.size() > 0) {\n                @SuppressWarnings(\"unused\")\n                Node unused = new Node.TemplateText(\n                        ttext.toString(), startMark, current);\n            }\n        }\n        startMark = new Mark(ctxt, path, locator.getLineNumber(),\n                             locator.getColumnNumber());\n\n        charBuffer = null;\n    }"}
{"idx": 525, "target": 1, "func": "@Override\n    public void startElement(\n        String uri,\n        String localName,\n        String qName,\n        Attributes attrs)\n        throws SAXException {\n\n        AttributesImpl taglibAttrs = null;\n        AttributesImpl nonTaglibAttrs = null;\n        AttributesImpl nonTaglibXmlnsAttrs = null;\n\n        processChars();\n\n        checkPrefixes(uri, qName, attrs);\n\n        if (directivesOnly &&\n            !(JSP_URI.equals(uri) && localName.startsWith(DIRECTIVE_ACTION))) {\n            return;\n        }\n\n        // jsp:text must not have any subelements\n        if (current instanceof Node.JspText) {\n            throw new SAXParseException(\n                Localizer.getMessage(\"jsp.error.text.has_subelement\"),\n                locator);\n        }\n\n        startMark = new Mark(ctxt, path, locator.getLineNumber(),\n                             locator.getColumnNumber());\n\n        if (attrs != null) {\n            /*\n             * Notice that due to a bug in the underlying SAX parser, the\n             * attributes must be enumerated in descending order.\n             */\n            boolean isTaglib = false;\n            for (int i = attrs.getLength() - 1; i >= 0; i--) {\n                isTaglib = false;\n                String attrQName = attrs.getQName(i);\n                if (!attrQName.startsWith(\"xmlns\")) {\n                    if (nonTaglibAttrs == null) {\n                        nonTaglibAttrs = new AttributesImpl();\n                    }\n                    nonTaglibAttrs.addAttribute(\n                        attrs.getURI(i),\n                        attrs.getLocalName(i),\n                        attrs.getQName(i),\n                        attrs.getType(i),\n                        attrs.getValue(i));\n                } else {\n                    if (attrQName.startsWith(\"xmlns:jsp\")) {\n                        isTaglib = true;\n                    } else {\n                        String attrUri = attrs.getValue(i);\n                        // TaglibInfo for this uri already established in\n                        // startPrefixMapping\n                        isTaglib = pageInfo.hasTaglib(attrUri);\n                    }\n                    if (isTaglib) {\n                        if (taglibAttrs == null) {\n                            taglibAttrs = new AttributesImpl();\n                        }\n                        taglibAttrs.addAttribute(\n                            attrs.getURI(i),\n                            attrs.getLocalName(i),\n                            attrs.getQName(i),\n                            attrs.getType(i),\n                            attrs.getValue(i));\n                    } else {\n                        if (nonTaglibXmlnsAttrs == null) {\n                            nonTaglibXmlnsAttrs = new AttributesImpl();\n                        }\n                        nonTaglibXmlnsAttrs.addAttribute(\n                            attrs.getURI(i),\n                            attrs.getLocalName(i),\n                            attrs.getQName(i),\n                            attrs.getType(i),\n                            attrs.getValue(i));\n                    }\n                }\n            }\n        }\n\n        Node node = null;\n\n        if (tagDependentPending && JSP_URI.equals(uri) &&\n                     localName.equals(BODY_ACTION)) {\n            tagDependentPending = false;\n            tagDependentNesting++;\n            current =\n                parseStandardAction(\n                    qName,\n                    localName,\n                    nonTaglibAttrs,\n                    nonTaglibXmlnsAttrs,\n                    taglibAttrs,\n                    startMark);\n            return;\n        }\n\n        if (tagDependentPending && JSP_URI.equals(uri) &&\n                     localName.equals(ATTRIBUTE_ACTION)) {\n            current =\n                parseStandardAction(\n                    qName,\n                    localName,\n                    nonTaglibAttrs,\n                    nonTaglibXmlnsAttrs,\n                    taglibAttrs,\n                    startMark);\n            return;\n        }\n\n        if (tagDependentPending) {\n            tagDependentPending = false;\n            tagDependentNesting++;\n        }\n\n        if (tagDependentNesting > 0) {\n            node =\n                new Node.UninterpretedTag(\n                    qName,\n                    localName,\n                    nonTaglibAttrs,\n                    nonTaglibXmlnsAttrs,\n                    taglibAttrs,\n                    startMark,\n                    current);\n        } else if (JSP_URI.equals(uri)) {\n            node =\n                parseStandardAction(\n                    qName,\n                    localName,\n                    nonTaglibAttrs,\n                    nonTaglibXmlnsAttrs,\n                    taglibAttrs,\n                    startMark);\n        } else {\n            node =\n                parseCustomAction(\n                    qName,\n                    localName,\n                    uri,\n                    nonTaglibAttrs,\n                    nonTaglibXmlnsAttrs,\n                    taglibAttrs,\n                    startMark,\n                    current);\n            if (node == null) {\n                node =\n                    new Node.UninterpretedTag(\n                        qName,\n                        localName,\n                        nonTaglibAttrs,\n                        nonTaglibXmlnsAttrs,\n                        taglibAttrs,\n                        startMark,\n                        current);\n            } else {\n                // custom action\n                String bodyType = getBodyType((Node.CustomTag) node);\n\n                if (scriptlessBodyNode == null\n                        && bodyType.equalsIgnoreCase(TagInfo.BODY_CONTENT_SCRIPTLESS)) {\n                    scriptlessBodyNode = node;\n                }\n                else if (TagInfo.BODY_CONTENT_TAG_DEPENDENT.equalsIgnoreCase(bodyType)) {\n                    tagDependentPending = true;\n                }\n            }\n        }\n\n        current = node;\n    }"}
{"idx": 526, "target": 0, "func": "private Boolean indexOf(char c, Mark mark) throws JasperException {\n        if (!hasMoreInput())\n            return null;\n\n        int end = current.stream.length;\n        int ch;\n        int line = current.line;\n        int col = current.col;\n        int i = current.cursor;\n        for(; i < end; i ++) {\n           ch = current.stream[i];\n\n           if (ch == c) {\n               mark.update(i, line, col);\n           }\n           if (ch == '\\n') {\n                line++;\n                col = 0;\n            } else {\n                col++;\n            }\n           if (ch == c) {\n               current.update(i+1, line, col);\n               return Boolean.TRUE;\n           }\n        }\n        current.update(i, line, col);\n        return Boolean.FALSE;\n    }"}
{"idx": 527, "target": 1, "func": "public void addSmap(int srcLine) {\n            if (extraSmap == null) {\n                extraSmap = new ArrayList<>();\n            }\n            extraSmap.add(new Integer(srcLine));\n        }"}
{"idx": 528, "target": 0, "func": "public JspAttribute[] getJspAttributes() {\n            return jspAttrs;\n        }"}
{"idx": 529, "target": 0, "func": "public void setJspAttributes(JspAttribute[] jspAttrs) {\n            this.jspAttrs = jspAttrs;\n        }"}
{"idx": 530, "target": 1, "func": "public void setBufferValue(String value, Node n, ErrorDispatcher err)\n        throws JasperException {\n\n        if (\"none\".equalsIgnoreCase(value))\n            buffer = 0;\n        else {\n            if (value == null || !value.endsWith(\"kb\")) {\n                if (n == null) {\n                    err.jspError(\"jsp.error.page.invalid.buffer\");\n                } else {\n                    err.jspError(n, \"jsp.error.page.invalid.buffer\");\n                }\n            }\n            try {\n                @SuppressWarnings(\"null\") // value can't be null here\n                Integer k = new Integer(value.substring(0, value.length()-2));\n                buffer = k.intValue() * 1024;\n            } catch (NumberFormatException e) {\n                if (n == null) {\n                    err.jspError(\"jsp.error.page.invalid.buffer\");\n                } else {\n                    err.jspError(n, \"jsp.error.page.invalid.buffer\");\n                }\n            }\n        }\n\n        bufferValue = value;\n    }"}
{"idx": 531, "target": 1, "func": "@Override\n        public void visit(Node.CustomTag n) throws JasperException {\n            n.setCustomTagParent(parent);\n            Node.CustomTag tmpParent = parent;\n            parent = n;\n            visitBody(n);\n            parent = tmpParent;\n            n.setNumCount(new Integer(count++));\n        }"}
{"idx": 532, "target": 1, "func": "static void install(File classFile, byte[] smap) throws IOException {\n            File tmpFile = new File(classFile.getPath() + \"tmp\");\n            SDEInstaller installer = new SDEInstaller(classFile, smap);\n            installer.install(tmpFile);\n            if (!classFile.delete()) {\n                throw new IOException(\"classFile.delete() failed\");\n            }\n            if (!tmpFile.renameTo(classFile)) {\n                throw new IOException(\"tmpFile.renameTo(classFile) failed\");\n            }\n        }"}
{"idx": 533, "target": 0, "func": "private Class<?> loadTagFile(Compiler compiler, String tagFilePath,\n            TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException {\n\n        Jar tagJar = null;\n        if (tagFilePath.startsWith(\"/META-INF/\")) {\n            try {\n                tagJar = compiler.getCompilationContext().getTldResourcePath(\n                            tagInfo.getTagLibrary().getURI()).getJar();\n            } catch (IOException ioe) {\n                throw new JasperException(ioe);\n            }\n        }\n        String wrapperUri;\n        if (tagJar == null) {\n            wrapperUri = tagFilePath;\n        } else {\n            wrapperUri = tagJar.getURL(tagFilePath);\n        }\n\n        JspCompilationContext ctxt = compiler.getCompilationContext();\n        JspRuntimeContext rctxt = ctxt.getRuntimeContext();\n\n        synchronized (rctxt) {\n            JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri);\n            if (wrapper == null) {\n                wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt\n                        .getOptions(), tagFilePath, tagInfo, ctxt\n                        .getRuntimeContext(), tagJar);\n                rctxt.addWrapper(wrapperUri, wrapper);\n\n                // Use same classloader and classpath for compiling tag files\n                wrapper.getJspEngineContext().setClassLoader(\n                        ctxt.getClassLoader());\n                wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath());\n            } else {\n                // Make sure that JspCompilationContext gets the latest TagInfo\n                // for the tag file. TagInfo instance was created the last\n                // time the tag file was scanned for directives, and the tag\n                // file may have been modified since then.\n                wrapper.getJspEngineContext().setTagInfo(tagInfo);\n            }\n\n            Class<?> tagClazz;\n            int tripCount = wrapper.incTripCount();\n            try {\n                if (tripCount > 0) {\n                    // When tripCount is greater than zero, a circular\n                    // dependency exists. The circularly dependent tag\n                    // file is compiled in prototype mode, to avoid infinite\n                    // recursion.\n\n                    JspServletWrapper tempWrapper = new JspServletWrapper(ctxt\n                            .getServletContext(), ctxt.getOptions(),\n                            tagFilePath, tagInfo, ctxt.getRuntimeContext(),\n                            tagJar);\n                    // Use same classloader and classpath for compiling tag files\n                    tempWrapper.getJspEngineContext().setClassLoader(\n                            ctxt.getClassLoader());\n                    tempWrapper.getJspEngineContext().setClassPath(ctxt.getClassPath());\n                    tagClazz = tempWrapper.loadTagFilePrototype();\n                    tempVector.add(tempWrapper.getJspEngineContext()\n                            .getCompiler());\n                } else {\n                    tagClazz = wrapper.loadTagFile();\n                }\n            } finally {\n                wrapper.decTripCount();\n            }\n\n            // Add the dependents for this tag file to its parent's\n            // Dependent list. The only reliable dependency information\n            // can only be obtained from the tag instance.\n            try {\n                Object tagIns = tagClazz.newInstance();\n                if (tagIns instanceof JspSourceDependent) {\n                    Iterator<Entry<String,Long>> iter = ((JspSourceDependent)\n                            tagIns).getDependants().entrySet().iterator();\n                    while (iter.hasNext()) {\n                        Entry<String,Long> entry = iter.next();\n                        parentPageInfo.addDependant(entry.getKey(),\n                                entry.getValue());\n                    }\n                }\n            } catch (Exception e) {\n                // ignore errors\n            }\n\n            return tagClazz;\n        }\n    }"}
{"idx": 534, "target": 0, "func": "private Class<?> loadTagFile(Compiler compiler, String tagFilePath,\n            TagInfo tagInfo, PageInfo parentPageInfo) throws JasperException {\n\n        Jar tagJar = null;\n        if (tagFilePath.startsWith(\"/META-INF/\")) {\n            try {\n                tagJar = compiler.getCompilationContext().getTldResourcePath(\n                            tagInfo.getTagLibrary().getURI()).getJar();\n            } catch (IOException ioe) {\n                throw new JasperException(ioe);\n            }\n        }\n        String wrapperUri;\n        if (tagJar == null) {\n            wrapperUri = tagFilePath;\n        } else {\n            wrapperUri = tagJar.getURL(tagFilePath);\n        }\n\n        JspCompilationContext ctxt = compiler.getCompilationContext();\n        JspRuntimeContext rctxt = ctxt.getRuntimeContext();\n\n        synchronized (rctxt) {\n            JspServletWrapper wrapper = rctxt.getWrapper(wrapperUri);\n            if (wrapper == null) {\n                wrapper = new JspServletWrapper(ctxt.getServletContext(), ctxt\n                        .getOptions(), tagFilePath, tagInfo, ctxt\n                        .getRuntimeContext(), tagJar);\n                rctxt.addWrapper(wrapperUri, wrapper);\n\n                // Use same classloader and classpath for compiling tag files\n                wrapper.getJspEngineContext().setClassLoader(\n                        ctxt.getClassLoader());\n                wrapper.getJspEngineContext().setClassPath(ctxt.getClassPath());\n            } else {\n                // Make sure that JspCompilationContext gets the latest TagInfo\n                // for the tag file. TagInfo instance was created the last\n                // time the tag file was scanned for directives, and the tag\n                // file may have been modified since then.\n                wrapper.getJspEngineContext().setTagInfo(tagInfo);\n            }\n\n            Class<?> tagClazz;\n            int tripCount = wrapper.incTripCount();\n            try {\n                if (tripCount > 0) {\n                    // When tripCount is greater than zero, a circular\n                    // dependency exists. The circularly dependent tag\n                    // file is compiled in prototype mode, to avoid infinite\n                    // recursion.\n\n                    JspServletWrapper tempWrapper = new JspServletWrapper(ctxt\n                            .getServletContext(), ctxt.getOptions(),\n                            tagFilePath, tagInfo, ctxt.getRuntimeContext(),\n                            tagJar);\n                    // Use same classloader and classpath for compiling tag files\n                    tempWrapper.getJspEngineContext().setClassLoader(\n                            ctxt.getClassLoader());\n                    tempWrapper.getJspEngineContext().setClassPath(ctxt.getClassPath());\n                    tagClazz = tempWrapper.loadTagFilePrototype();\n                    tempVector.add(tempWrapper.getJspEngineContext()\n                            .getCompiler());\n                } else {\n                    tagClazz = wrapper.loadTagFile();\n                }\n            } finally {\n                wrapper.decTripCount();\n            }\n\n            // Add the dependents for this tag file to its parent's\n            // Dependent list. The only reliable dependency information\n            // can only be obtained from the tag instance.\n            try {\n                Object tagIns = tagClazz.newInstance();\n                if (tagIns instanceof JspSourceDependent) {\n                    Iterator<Entry<String,Long>> iter = ((JspSourceDependent)\n                            tagIns).getDependants().entrySet().iterator();\n                    while (iter.hasNext()) {\n                        Entry<String,Long> entry = iter.next();\n                        parentPageInfo.addDependant(entry.getKey(),\n                                entry.getValue());\n                    }\n                }\n            } catch (Exception e) {\n                // ignore errors\n            }\n\n            return tagClazz;\n        }\n    }"}
{"idx": 535, "target": 1, "func": "void postCheck() throws JasperException {\n            // Check that var.name-from-attributes has valid values.\n            Iterator<String> iter = nameFromTable.keySet().iterator();\n            while (iter.hasNext()) {\n                String nameFrom = iter.next();\n                NameEntry nameEntry = nameTable.get(nameFrom);\n                NameEntry nameFromEntry = nameFromTable.get(nameFrom);\n                Node nameFromNode = nameFromEntry.getNode();\n                if (nameEntry == null) {\n                    err.jspError(nameFromNode,\n                            \"jsp.error.tagfile.nameFrom.noAttribute\", nameFrom);\n                } else {\n                    Node node = nameEntry.getNode();\n                    TagAttributeInfo tagAttr = nameEntry.getTagAttributeInfo();\n                    if (!\"java.lang.String\".equals(tagAttr.getTypeName())\n                            || !tagAttr.isRequired()\n                            || tagAttr.canBeRequestTime()) {\n                        err.jspError(nameFromNode,\n                                \"jsp.error.tagfile.nameFrom.badAttribute\",\n                                nameFrom, Integer.toString(node.getStart()\n                                        .getLineNumber()));\n                    }\n                }\n            }\n        }"}
{"idx": 536, "target": 0, "func": "private void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = Constants.IS_SECURITY_ENABLED;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser = new TagPluginParser(ctxt, blockExternal);\n\n        try {\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }"}
{"idx": 537, "target": 0, "func": "private void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = Constants.IS_SECURITY_ENABLED;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser = new TagPluginParser(ctxt, blockExternal);\n\n        try {\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }"}
{"idx": 538, "target": 1, "func": "public static void createTypedArray(String propertyName,\n                                        Object bean,\n                                        Method method,\n                                        String[] values,\n                                        Class<?> t,\n                                        Class<?> propertyEditorClass)\n                throws JasperException {\n\n        try {\n            if (propertyEditorClass != null) {\n                Object[] tmpval = new Integer[values.length];\n                for (int i=0; i<values.length; i++) {\n                    tmpval[i] = getValueFromBeanInfoPropertyEditor(\n                            t, propertyName, values[i], propertyEditorClass);\n                }\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Integer.class)) {\n                Integer []tmpval = new Integer[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] =  new Integer (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Byte.class)) {\n                Byte[] tmpval = new Byte[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Byte (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Boolean.class)) {\n                Boolean[] tmpval = new Boolean[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Boolean.valueOf(values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Short.class)) {\n                Short[] tmpval = new Short[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Short (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Long.class)) {\n                Long[] tmpval = new Long[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Long (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Double.class)) {\n                Double[] tmpval = new Double[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Double (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Float.class)) {\n                Float[] tmpval = new Float[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Float (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Character.class)) {\n                Character[] tmpval = new Character[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Character.valueOf(values[i].charAt(0));\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(int.class)) {\n                int []tmpval = new int[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Integer.parseInt (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(byte.class)) {\n                byte[] tmpval = new byte[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Byte.parseByte (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(boolean.class)) {\n                boolean[] tmpval = new boolean[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = (Boolean.valueOf(values[i])).booleanValue();\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(short.class)) {\n                short[] tmpval = new short[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Short.parseShort (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(long.class)) {\n                long[] tmpval = new long[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Long.parseLong (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(double.class)) {\n                double[] tmpval = new double[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Double.valueOf(values[i]).doubleValue();\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(float.class)) {\n                float[] tmpval = new float[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Float.valueOf(values[i]).floatValue();\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(char.class)) {\n                char[] tmpval = new char[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = values[i].charAt(0);\n                method.invoke (bean, new Object[] {tmpval});\n            } else {\n                Object[] tmpval = new Integer[values.length];\n                for (int i=0; i<values.length; i++) {\n                    tmpval[i] =\n                        getValueFromPropertyEditorManager(\n                                            t, propertyName, values[i]);\n                }\n                method.invoke (bean, new Object[] {tmpval});\n            }\n        } catch (Exception ex) {\n            Throwable thr = ExceptionUtils.unwrapInvocationTargetException(ex);\n            ExceptionUtils.handleThrowable(thr);\n            throw new JasperException (\"error in invoking method\", ex);\n        }\n    }"}
{"idx": 539, "target": 0, "func": "public static Method getReadMethod(Class<?> beanClass, String prop)\n            throws JasperException {\n\n        Method method = null;\n        Class<?> type = null;\n        try {\n            java.beans.BeanInfo info\n                = java.beans.Introspector.getBeanInfo(beanClass);\n            if ( info != null ) {\n                java.beans.PropertyDescriptor pd[]\n                    = info.getPropertyDescriptors();\n                for (int i = 0 ; i < pd.length ; i++) {\n                    if ( pd[i].getName().equals(prop) ) {\n                        method = pd[i].getReadMethod();\n                        type   = pd[i].getPropertyType();\n                        break;\n                    }\n                }\n            } else {\n                // just in case introspection silently fails.\n                throw new JasperException(\n                    Localizer.getMessage(\"jsp.error.beans.nobeaninfo\",\n                                         beanClass.getName()));\n            }\n        } catch (Exception ex) {\n            throw new JasperException (ex);\n        }\n        if (method == null) {\n            if (type == null) {\n                throw new JasperException(\n                    Localizer.getMessage(\"jsp.error.beans.noproperty\", prop,\n                                         beanClass.getName()));\n            } else {\n                throw new JasperException(\n                    Localizer.getMessage(\"jsp.error.beans.nomethod\", prop,\n                                         beanClass.getName()));\n            }\n        }\n\n        return method;\n    }"}
{"idx": 540, "target": 1, "func": "public static String escapeQueryString(String unescString) {\n    if ( unescString == null )\n        return null;\n\n    String escString    = \"\";\n    String shellSpChars = \"&;`'\\\"|*?~<>^()[]{}$\\\\\\n\";\n\n    for(int index=0; index<unescString.length(); index++) {\n        char nextChar = unescString.charAt(index);\n\n        if( shellSpChars.indexOf(nextChar) != -1 )\n        escString += \"\\\\\";\n\n        escString += nextChar;\n    }\n    return escString;\n    }"}
{"idx": 541, "target": 0, "func": "@Override\n    public void forward(final String relativeUrlPath) throws ServletException,\n            IOException {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            try {\n                AccessController.doPrivileged(\n                        new PrivilegedExceptionAction<Void>() {\n                    @Override\n                    public Void run() throws Exception {\n                        doForward(relativeUrlPath);\n                        return null;\n                    }\n                });\n            } catch (PrivilegedActionException e) {\n                Exception ex = e.getException();\n                if (ex instanceof IOException) {\n                    throw (IOException) ex;\n                } else {\n                    throw (ServletException) ex;\n                }\n            }\n        } else {\n            doForward(relativeUrlPath);\n        }\n    }"}
{"idx": 542, "target": 0, "func": "@Override\n    public void handlePageException(Exception ex) throws IOException,\n            ServletException {\n        // Should never be called since handleException() called with a\n        // Throwable in the generated servlet.\n        handlePageException((Throwable) ex);\n    }"}
{"idx": 543, "target": 1, "func": "@Override\n    public Set<String> getResourcePaths(String path) {\n\n        Set<String> thePaths = new HashSet<>();\n        if (!path.endsWith(\"/\"))\n            path += \"/\";\n        String basePath = getRealPath(path);\n        if (basePath == null)\n            return (thePaths);\n        File theBaseDir = new File(basePath);\n        if (!theBaseDir.exists() || !theBaseDir.isDirectory())\n            return (thePaths);\n        String theFiles[] = theBaseDir.list();\n        for (int i = 0; i < theFiles.length; i++) {\n            File testFile = new File(basePath + File.separator + theFiles[i]);\n            if (testFile.isFile())\n                thePaths.add(path + theFiles[i]);\n            else if (testFile.isDirectory())\n                thePaths.add(path + theFiles[i] + \"/\");\n        }\n        return (thePaths);\n\n    }"}
{"idx": 544, "target": 0, "func": "protected JasperException handleJspException(Exception ex) {\n        try {\n            Throwable realException = ex;\n            if (ex instanceof ServletException) {\n                realException = ((ServletException) ex).getRootCause();\n            }\n\n            // First identify the stack frame in the trace that represents the JSP\n            StackTraceElement[] frames = realException.getStackTrace();\n            StackTraceElement jspFrame = null;\n\n            for (int i=0; i<frames.length; ++i) {\n                if ( frames[i].getClassName().equals(this.getServlet().getClass().getName()) ) {\n                    jspFrame = frames[i];\n                    break;\n                }\n            }\n\n\n            if (jspFrame == null ||\n                    this.ctxt.getCompiler().getPageNodes() == null) {\n                // If we couldn't find a frame in the stack trace corresponding\n                // to the generated servlet class or we don't have a copy of the\n                // parsed JSP to hand, we can't really add anything\n                return new JasperException(ex);\n            }\n\n            int javaLineNumber = jspFrame.getLineNumber();\n            JavacErrorDetail detail = ErrorDispatcher.createJavacError(\n                    jspFrame.getMethodName(),\n                    this.ctxt.getCompiler().getPageNodes(),\n                    null,\n                    javaLineNumber,\n                    ctxt);\n\n            // If the line number is less than one we couldn't find out\n            // where in the JSP things went wrong\n            int jspLineNumber = detail.getJspBeginLineNumber();\n            if (jspLineNumber < 1) {\n                throw new JasperException(ex);\n            }\n\n            if (options.getDisplaySourceFragment()) {\n                return new JasperException(Localizer.getMessage\n                        (\"jsp.exception\", detail.getJspFileName(),\n                                \"\" + jspLineNumber) + Constants.NEWLINE +\n                                Constants.NEWLINE + detail.getJspExtract() +\n                                Constants.NEWLINE + Constants.NEWLINE +\n                                \"Stacktrace:\", ex);\n\n            }\n\n            return new JasperException(Localizer.getMessage\n                    (\"jsp.exception\", detail.getJspFileName(),\n                            \"\" + jspLineNumber), ex);\n        } catch (Exception je) {\n            // If anything goes wrong, just revert to the original behaviour\n            if (ex instanceof JasperException) {\n                return (JasperException) ex;\n            }\n            return new JasperException(ex);\n        }\n    }"}
{"idx": 545, "target": 1, "func": "@Override\n                public FileVisitResult visitFile(Path file,\n                                                 BasicFileAttributes attrs)\n                        throws IOException {\n                    if (!file.getFileName().toString()\n                            .toLowerCase(Locale.ENGLISH).endsWith(TLD_EXT)) {\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    String subPath = file.subpath(\n                            filePath.getNameCount(), file.getNameCount()).toString();\n                    if ('/' != File.separatorChar) {\n                        subPath = subPath.replace(File.separatorChar, '/');\n                    }\n                    String resourcePath = webappPath + \"/\" + subPath;\n\n                    try {\n                        URL url = file.toUri().toURL();\n                        TldResourcePath path = new TldResourcePath(url, resourcePath);\n                        parseTld(path);\n                        tldFound = true;\n                    } catch (SAXException e) {\n                        throw new IOException(e);\n                    }\n                    return FileVisitResult.CONTINUE;\n                }"}
{"idx": 546, "target": 0, "func": "private void scanXMLDeclOrTextDecl(boolean scanningTextDecl)\n        throws IOException, JasperException {\n\n        // scan decl\n        scanXMLDeclOrTextDecl(scanningTextDecl, fStrings);\n\n        // pseudo-attribute values\n        String encodingPseudoAttr = fStrings[1];\n\n        // set encoding on reader\n        if (encodingPseudoAttr != null) {\n            isEncodingSetInProlog = true;\n            encoding = encodingPseudoAttr;\n        }\n    }"}
{"idx": 547, "target": 0, "func": "final boolean load(int offset, boolean changeEntity)\n        throws IOException {\n\n        // read characters\n        int count = fCurrentEntity.reader.read(fCurrentEntity.ch, offset,\n                DEFAULT_XMLDECL_BUFFER_SIZE);\n\n        // reset count and position\n        boolean entityChanged = false;\n        if (count != -1) {\n            if (count != 0) {\n                fCurrentEntity.count = count + offset;\n                fCurrentEntity.position = offset;\n            }\n        }\n\n        // end of this entity\n        else {\n            fCurrentEntity.count = offset;\n            fCurrentEntity.position = offset;\n            entityChanged = true;\n            if (changeEntity) {\n                endEntity();\n                if (fCurrentEntity == null) {\n                    throw new EOFException();\n                }\n                // handle the trailing edges\n                if (fCurrentEntity.position == fCurrentEntity.count) {\n                    load(0, false);\n                }\n            }\n        }\n\n        return entityChanged;\n\n    }"}
{"idx": 548, "target": 1, "func": "@Override\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx,\n                                    Hashtable<?,?> environment)\n        throws NamingException {\n\n        if (obj instanceof ResourceRef) {\n\n            try {\n\n                Reference ref = (Reference) obj;\n                String beanClassName = ref.getClassName();\n                Class<?> beanClass = null;\n                ClassLoader tcl =\n                    Thread.currentThread().getContextClassLoader();\n                if (tcl != null) {\n                    try {\n                        beanClass = tcl.loadClass(beanClassName);\n                    } catch(ClassNotFoundException e) {\n                    }\n                } else {\n                    try {\n                        beanClass = Class.forName(beanClassName);\n                    } catch(ClassNotFoundException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if (beanClass == null) {\n                    throw new NamingException\n                        (\"Class not found: \" + beanClassName);\n                }\n\n                BeanInfo bi = Introspector.getBeanInfo(beanClass);\n                PropertyDescriptor[] pda = bi.getPropertyDescriptors();\n\n                Object bean = beanClass.newInstance();\n\n                Enumeration<RefAddr> e = ref.getAll();\n                while (e.hasMoreElements()) {\n\n                    RefAddr ra = e.nextElement();\n                    String propName = ra.getType();\n\n                    if (propName.equals(Constants.FACTORY) ||\n                        propName.equals(\"scope\") || propName.equals(\"auth\") ||\n                        propName.equals(\"singleton\")) {\n                        continue;\n                    }\n\n                    String value = (String)ra.getContent();\n\n                    Object[] valueArray = new Object[1];\n\n                    int i = 0;\n                    for (i = 0; i<pda.length; i++) {\n\n                        if (pda[i].getName().equals(propName)) {\n\n                            Class<?> propType = pda[i].getPropertyType();\n\n                            if (propType.equals(String.class)) {\n                                valueArray[0] = value;\n                            } else if (propType.equals(Character.class)\n                                       || propType.equals(char.class)) {\n                                valueArray[0] =\n                                    Character.valueOf(value.charAt(0));\n                            } else if (propType.equals(Byte.class)\n                                       || propType.equals(byte.class)) {\n                                valueArray[0] = new Byte(value);\n                            } else if (propType.equals(Short.class)\n                                       || propType.equals(short.class)) {\n                                valueArray[0] = new Short(value);\n                            } else if (propType.equals(Integer.class)\n                                       || propType.equals(int.class)) {\n                                valueArray[0] = new Integer(value);\n                            } else if (propType.equals(Long.class)\n                                       || propType.equals(long.class)) {\n                                valueArray[0] = new Long(value);\n                            } else if (propType.equals(Float.class)\n                                       || propType.equals(float.class)) {\n                                valueArray[0] = new Float(value);\n                            } else if (propType.equals(Double.class)\n                                       || propType.equals(double.class)) {\n                                valueArray[0] = new Double(value);\n                            } else if (propType.equals(Boolean.class)\n                                       || propType.equals(boolean.class)) {\n                                valueArray[0] = Boolean.valueOf(value);\n                            } else {\n                                throw new NamingException\n                                    (\"String conversion for property type '\"\n                                     + propType.getName() + \"' not available\");\n                            }\n\n                            Method setProp = pda[i].getWriteMethod();\n                            if (setProp != null) {\n                                setProp.invoke(bean, valueArray);\n                            } else {\n                                throw new NamingException\n                                    (\"Write not allowed for property: \"\n                                     + propName);\n                            }\n\n                            break;\n\n                        }\n\n                    }\n\n                    if (i == pda.length) {\n                        throw new NamingException\n                            (\"No set method found for property: \" + propName);\n                    }\n\n                }\n\n                return bean;\n\n            } catch (java.beans.IntrospectionException ie) {\n                NamingException ne = new NamingException(ie.getMessage());\n                ne.setRootCause(ie);\n                throw ne;\n            } catch (java.lang.IllegalAccessException iae) {\n                NamingException ne = new NamingException(iae.getMessage());\n                ne.setRootCause(iae);\n                throw ne;\n            } catch (java.lang.InstantiationException ie2) {\n                NamingException ne = new NamingException(ie2.getMessage());\n                ne.setRootCause(ie2);\n                throw ne;\n            } catch (java.lang.reflect.InvocationTargetException ite) {\n                Throwable cause = ite.getCause();\n                if (cause instanceof ThreadDeath) {\n                    throw (ThreadDeath) cause;\n                }\n                if (cause instanceof VirtualMachineError) {\n                    throw (VirtualMachineError) cause;\n                }\n                NamingException ne = new NamingException(ite.getMessage());\n                ne.setRootCause(ite);\n                throw ne;\n            }\n\n        } else {\n            return null;\n        }\n\n    }"}
{"idx": 549, "target": 1, "func": "@SuppressWarnings(\"null\") // setPropertyMethodVoid can't be null when used\n    private static boolean setProperty(Object o, String name, String value) {\n        if (log.isDebugEnabled())\n            log.debug(\"IntrospectionUtils: setProperty(\" +\n                    o.getClass() + \" \" + name + \"=\" + value + \")\");\n\n        String setter = \"set\" + capitalize(name);\n\n        try {\n            Method methods[] = o.getClass().getMethods();\n            Method setPropertyMethodVoid = null;\n            Method setPropertyMethodBool = null;\n\n            // First, the ideal case - a setFoo( String ) method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 1\n                        && \"java.lang.String\".equals(paramT[0].getName())) {\n\n                    methods[i].invoke(o, new Object[] { value });\n                    return true;\n                }\n            }\n\n            // Try a setFoo ( int ) or ( boolean )\n            for (int i = 0; i < methods.length; i++) {\n                boolean ok = true;\n                if (setter.equals(methods[i].getName())\n                        && methods[i].getParameterTypes().length == 1) {\n\n                    // match - find the type and invoke it\n                    Class<?> paramType = methods[i].getParameterTypes()[0];\n                    Object params[] = new Object[1];\n\n                    // Try a setFoo ( int )\n                    if (\"java.lang.Integer\".equals(paramType.getName())\n                            || \"int\".equals(paramType.getName())) {\n                        try {\n                            params[0] = new Integer(value);\n                        } catch (NumberFormatException ex) {\n                            ok = false;\n                        }\n                    // Try a setFoo ( long )\n                    }else if (\"java.lang.Long\".equals(paramType.getName())\n                                || \"long\".equals(paramType.getName())) {\n                            try {\n                                params[0] = new Long(value);\n                            } catch (NumberFormatException ex) {\n                                ok = false;\n                            }\n\n                        // Try a setFoo ( boolean )\n                    } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                            || \"boolean\".equals(paramType.getName())) {\n                        params[0] = Boolean.valueOf(value);\n\n                        // Try a setFoo ( InetAddress )\n                    } else if (\"java.net.InetAddress\".equals(paramType\n                            .getName())) {\n                        try {\n                            params[0] = InetAddress.getByName(value);\n                        } catch (UnknownHostException exc) {\n                            if (log.isDebugEnabled())\n                                log.debug(\"IntrospectionUtils: Unable to resolve host name:\" + value);\n                            ok = false;\n                        }\n\n                        // Unknown type\n                    } else {\n                        if (log.isDebugEnabled())\n                            log.debug(\"IntrospectionUtils: Unknown type \" +\n                                    paramType.getName());\n                    }\n\n                    if (ok) {\n                        methods[i].invoke(o, params);\n                        return true;\n                    }\n                }\n\n                // save \"setProperty\" for later\n                if (\"setProperty\".equals(methods[i].getName())) {\n                    if (methods[i].getReturnType()==Boolean.TYPE){\n                        setPropertyMethodBool = methods[i];\n                    }else {\n                        setPropertyMethodVoid = methods[i];\n                    }\n\n                }\n            }\n\n            // Ok, no setXXX found, try a setProperty(\"name\", \"value\")\n            if (setPropertyMethodBool != null || setPropertyMethodVoid != null) {\n                Object params[] = new Object[2];\n                params[0] = name;\n                params[1] = value;\n                if (setPropertyMethodBool != null) {\n                    try {\n                        return ((Boolean) setPropertyMethodBool.invoke(o, params)).booleanValue();\n                    }catch (IllegalArgumentException biae) {\n                        //the boolean method had the wrong\n                        //parameter types. lets try the other\n                        if (setPropertyMethodVoid!=null) {\n                            setPropertyMethodVoid.invoke(o, params);\n                            return true;\n                        }else {\n                            throw biae;\n                        }\n                    }\n                } else {\n                    setPropertyMethodVoid.invoke(o, params);\n                    return true;\n                }\n            }\n\n        } catch (IllegalArgumentException ex2) {\n            log.warn(\"IAE \" + o + \" \" + name + \" \" + value, ex2);\n        } catch (SecurityException ex1) {\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: SecurityException for \" +\n                        o.getClass() + \" \" + name + \"=\" + value + \")\", ex1);\n        } catch (IllegalAccessException iae) {\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: IllegalAccessException for \" +\n                        o.getClass() + \" \" + name + \"=\" + value + \")\", iae);\n        } catch (InvocationTargetException ie) {\n            Throwable cause = ie.getCause();\n            if (cause instanceof ThreadDeath) {\n                throw (ThreadDeath) cause;\n            }\n            if (cause instanceof VirtualMachineError) {\n                throw (VirtualMachineError) cause;\n            }\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: InvocationTargetException for \" +\n                        o.getClass() + \" \" + name + \"=\" + value + \")\", ie);\n        }\n        return false;\n    }"}
{"idx": 550, "target": 1, "func": "public static Object convert(String object, Class<?> paramType) {\n        Object result = null;\n        if (\"java.lang.String\".equals(paramType.getName())) {\n            result = object;\n        } else if (\"java.lang.Integer\".equals(paramType.getName())\n                || \"int\".equals(paramType.getName())) {\n            try {\n                result = new Integer(object);\n            } catch (NumberFormatException ex) {\n            }\n            // Try a setFoo ( boolean )\n        } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                || \"boolean\".equals(paramType.getName())) {\n            result = Boolean.valueOf(object);\n\n            // Try a setFoo ( InetAddress )\n        } else if (\"java.net.InetAddress\".equals(paramType\n                .getName())) {\n            try {\n                result = InetAddress.getByName(object);\n            } catch (UnknownHostException exc) {\n                if (log.isDebugEnabled())\n                    log.debug(\"IntrospectionUtils: Unable to resolve host name:\" +\n                            object);\n            }\n\n            // Unknown type\n        } else {\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: Unknown type \" +\n                        paramType.getName());\n        }\n        if (result == null) {\n            throw new IllegalArgumentException(\"Can't convert argument: \" + object);\n        }\n        return result;\n    }"}
{"idx": 551, "target": 1, "func": "public static boolean setProperty(Object o, String name, String value) {\n        return setProperty(o,name,value,true);\n    }"}
{"idx": 552, "target": 0, "func": "@SuppressWarnings(\"null\") // Neither params nor methodParams can be null\n                              // when comparing their lengths\n    public static Method findMethod(Class<?> c, String name,\n            Class<?> params[]) {\n        Method methods[] = findMethods(c);\n        if (methods == null)\n            return null;\n        for (int i = 0; i < methods.length; i++) {\n            if (methods[i].getName().equals(name)) {\n                Class<?> methodParams[] = methods[i].getParameterTypes();\n                if (methodParams == null)\n                    if (params == null || params.length == 0)\n                        return methods[i];\n                if (params == null)\n                    if (methodParams == null || methodParams.length == 0)\n                        return methods[i];\n                if (params.length != methodParams.length)\n                    continue;\n                boolean found = true;\n                for (int j = 0; j < params.length; j++) {\n                    if (params[j] != methodParams[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n                if (found)\n                    return methods[i];\n            }\n        }\n        return null;\n    }"}
{"idx": 553, "target": 0, "func": "@SuppressWarnings(\"null\") // Neither params nor methodParams can be null\n                              // when comparing their lengths\n    public static Method findMethod(Class<?> c, String name,\n            Class<?> params[]) {\n        Method methods[] = findMethods(c);\n        if (methods == null)\n            return null;\n        for (int i = 0; i < methods.length; i++) {\n            if (methods[i].getName().equals(name)) {\n                Class<?> methodParams[] = methods[i].getParameterTypes();\n                if (methodParams == null)\n                    if (params == null || params.length == 0)\n                        return methods[i];\n                if (params == null)\n                    if (methodParams == null || methodParams.length == 0)\n                        return methods[i];\n                if (params.length != methodParams.length)\n                    continue;\n                boolean found = true;\n                for (int j = 0; j < params.length; j++) {\n                    if (params[j] != methodParams[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n                if (found)\n                    return methods[i];\n            }\n        }\n        return null;\n    }"}
{"idx": 554, "target": 0, "func": "@SuppressWarnings(\"null\") // Neither params nor methodParams can be null\n                              // when comparing their lengths\n    public static Method findMethod(Class<?> c, String name,\n            Class<?> params[]) {\n        Method methods[] = findMethods(c);\n        if (methods == null)\n            return null;\n        for (int i = 0; i < methods.length; i++) {\n            if (methods[i].getName().equals(name)) {\n                Class<?> methodParams[] = methods[i].getParameterTypes();\n                if (methodParams == null)\n                    if (params == null || params.length == 0)\n                        return methods[i];\n                if (params == null)\n                    if (methodParams == null || methodParams.length == 0)\n                        return methods[i];\n                if (params.length != methodParams.length)\n                    continue;\n                boolean found = true;\n                for (int j = 0; j < params.length; j++) {\n                    if (params[j] != methodParams[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n                if (found)\n                    return methods[i];\n            }\n        }\n        return null;\n    }"}
{"idx": 555, "target": 1, "func": "@Override\n    public void scan(JarURLConnection jarConn, String webappPath, boolean isWebapp)\n            throws IOException {\n\n        URL url = jarConn.getURL();\n        URL resourceURL = jarConn.getJarFileURL();\n        Jar jar = null;\n        InputStream is = null;\n        WebXml fragment = new WebXml();\n        fragment.setWebappJar(isWebapp);\n        fragment.setDelegate(delegate);\n\n        try {\n            // Only web application JARs are checked for web-fragment.xml\n            // files.\n            // web-fragment.xml files don't need to be parsed if they are never\n            // going to be used.\n            if (isWebapp && parseRequired) {\n                jar = JarFactory.newInstance(url);\n                is = jar.getInputStream(FRAGMENT_LOCATION);\n            }\n\n            if (is == null) {\n                // If there is no web.xml, normal JAR no impact on\n                // distributable\n                fragment.setDistributable(true);\n            } else {\n                InputSource source = new InputSource(\n                        \"jar:\" + resourceURL.toString() + \"!/\" + FRAGMENT_LOCATION);\n                source.setByteStream(is);\n                if (!webXmlParser.parseWebXml(source, fragment, true)) {\n                    ok = false;\n                }\n            }\n        } finally {\n            if (jar != null) {\n                jar.close();\n            }\n            fragment.setURL(url);\n            if (fragment.getName() == null) {\n                fragment.setName(fragment.getURL().toString());\n            }\n            fragment.setJarName(extractJarFileName(url));\n            fragments.put(fragment.getName(), fragment);\n        }\n    }"}
{"idx": 556, "target": 1, "func": "public static final String formatDate\n        (long value, DateFormat threadLocalformat) {\n\n        Long longValue = new Long(value);\n        String cachedDate = formatCache.get(longValue);\n        if (cachedDate != null) {\n            return cachedDate;\n        }\n\n        String newDate = null;\n        Date dateValue = new Date(value);\n        if (threadLocalformat != null) {\n            newDate = threadLocalformat.format(dateValue);\n            updateFormatCache(longValue, newDate);\n        } else {\n            synchronized (format) {\n                newDate = format.format(dateValue);\n            }\n            updateFormatCache(longValue, newDate);\n        }\n        return newDate;\n    }"}
{"idx": 557, "target": 1, "func": "private static final Long internalParseDate\n        (String value, DateFormat[] formats) {\n        Date date = null;\n        for (int i = 0; (date == null) && (i < formats.length); i++) {\n            try {\n                date = formats[i].parse(value);\n            } catch (ParseException e) {\n                // Ignore\n            }\n        }\n        if (date == null) {\n            return null;\n        }\n        return new Long(date.getTime());\n    }"}
{"idx": 558, "target": 0, "func": "@Override\n    public String toString() {\n        return new String(toByteArray());\n    }"}
{"idx": 559, "target": 0, "func": "@Override\n    protected void thresholdReached() throws IOException\n    {\n        if (prefix != null) {\n            outputFile = File.createTempFile(prefix, suffix, directory);\n        }\n        FileOutputStream fos = new FileOutputStream(outputFile);\n        memoryOutputStream.writeTo(fos);\n        currentOutputStream = fos;\n        memoryOutputStream = null;\n    }"}
{"idx": 560, "target": 0, "func": "public byte[] getData()\n    {\n        if (memoryOutputStream != null)\n        {\n            return memoryOutputStream.toByteArray();\n        }\n        return null;\n    }"}
{"idx": 561, "target": 1, "func": "@Override\n    public byte[] get() {\n        if (isInMemory()) {\n            if (cachedContent == null) {\n                cachedContent = dfos.getData();\n            }\n            return cachedContent;\n        }\n\n        byte[] fileData = new byte[(int) getSize()];\n        InputStream fis = null;\n\n        try {\n            fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));\n            fis.read(fileData);\n        } catch (IOException e) {\n            fileData = null;\n        } finally {\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n\n        return fileData;\n    }"}
{"idx": 562, "target": 0, "func": "@Override\n    public void delete() {\n        cachedContent = null;\n        File outputFile = getStoreLocation();\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }"}
{"idx": 563, "target": 0, "func": "@Override\n    protected void finalize() {\n        File outputFile = dfos.getFile();\n\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }"}
{"idx": 564, "target": 1, "func": "public Object convertValue(String type, String value)\n    {\n        Object objValue=value;\n\n        if( type==null || \"java.lang.String\".equals( type )) {\n            // string is default\n            objValue=value;\n        } else if( \"javax.management.ObjectName\".equals( type ) ||\n                \"ObjectName\".equals( type )) {\n            try {\n                objValue=new ObjectName( value );\n            } catch (MalformedObjectNameException e) {\n                return null;\n            }\n        } else if( \"java.lang.Integer\".equals( type ) ||\n                \"int\".equals( type )) {\n            objValue=new Integer( value );\n        } else if( \"java.lang.Long\".equals( type ) ||\n                \"long\".equals( type )) {\n            objValue=new Long( value );\n        } else if( \"java.lang.Boolean\".equals( type ) ||\n                \"boolean\".equals( type )) {\n            objValue=Boolean.valueOf( value );\n        }\n        return objValue;\n    }"}
{"idx": 565, "target": 1, "func": "@Override\n    public synchronized int getId( String domain, String name) {\n        if( domain==null) {\n            domain=\"\";\n        }\n        Hashtable<String,Integer> domainTable = idDomains.get(domain);\n        if( domainTable == null ) {\n            domainTable = new Hashtable<>();\n            idDomains.put( domain, domainTable);\n        }\n        if( name==null ) {\n            name=\"\";\n        }\n        Integer i = domainTable.get(name);\n\n        if( i!= null ) {\n            return i.intValue();\n        }\n\n        int id[] = ids.get(domain);\n        if( id == null ) {\n            id=new int[1];\n            ids.put( domain, id);\n        }\n        int code=id[0]++;\n        domainTable.put( name, new Integer( code ));\n        return code;\n    }"}
{"idx": 566, "target": 0, "func": "public List<ObjectName> load( String sourceType, Object source,\n            String param) throws Exception {\n        if( log.isTraceEnabled()) {\n            log.trace(\"load \" + source );\n        }\n        String location=null;\n        String type=null;\n        Object inputsource=null;\n\n        if( source instanceof URL ) {\n            URL url=(URL)source;\n            location=url.toString();\n            type=param;\n            inputsource=url.openStream();\n            if (sourceType == null && location.endsWith(\".xml\")) {\n                sourceType = \"MbeansDescriptorsDigesterSource\";\n            }\n        } else if( source instanceof File ) {\n            location=((File)source).getAbsolutePath();\n            inputsource=new FileInputStream((File)source);\n            type=param;\n            if (sourceType == null && location.endsWith(\".xml\")) {\n                sourceType = \"MbeansDescriptorsDigesterSource\";\n            }\n        } else if( source instanceof InputStream ) {\n            type=param;\n            inputsource=source;\n        } else if( source instanceof Class<?> ) {\n            location=((Class<?>)source).getName();\n            type=param;\n            inputsource=source;\n            if( sourceType== null ) {\n                sourceType=\"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n\n        if( sourceType==null ) {\n            sourceType=\"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds=getModelerSource(sourceType);\n        List<ObjectName> mbeans =\n            ds.loadDescriptors(this, type, inputsource);\n\n        return mbeans;\n    }"}
{"idx": 567, "target": 0, "func": "private void findDescriptor(Class<?> beanClass, String type) {\n        if( type==null ) {\n            type=beanClass.getName();\n        }\n        ClassLoader classLoader=null;\n        if( beanClass!=null ) {\n            classLoader=beanClass.getClassLoader();\n        }\n        if( classLoader==null ) {\n            classLoader=Thread.currentThread().getContextClassLoader();\n        }\n        if( classLoader==null ) {\n            classLoader=this.getClass().getClassLoader();\n        }\n\n        String className=type;\n        String pkg=className;\n        while( pkg.indexOf( \".\") > 0 ) {\n            int lastComp=pkg.lastIndexOf( \".\");\n            if( lastComp <= 0 ) return;\n            pkg=pkg.substring(0, lastComp);\n            if( searchedPaths.get( pkg ) != null ) {\n                return;\n            }\n            loadDescriptors(pkg, classLoader);\n        }\n        return;\n    }"}
{"idx": 568, "target": 0, "func": "public void execute() throws Exception {\n        if (registry == null) {\n            registry = Registry.getRegistry(null, null);\n        }\n\n        InputStream stream = (InputStream) source;\n\n        if (digester == null) {\n            digester = createDigester();\n        }\n        ArrayList<ManagedBean> loadedMbeans = new ArrayList<>();\n\n        synchronized (digester) {\n\n            // Process the input file to configure our registry\n            try {\n                // Push our registry object onto the stack\n                digester.push(loadedMbeans);\n                digester.parse(stream);\n            } catch (Exception e) {\n                log.error(\"Error digesting Registry data\", e);\n                throw e;\n            } finally {\n                digester.reset();\n            }\n\n        }\n        Iterator<ManagedBean> iter = loadedMbeans.iterator();\n        while (iter.hasNext()) {\n            registry.addManagedBean(iter.next());\n        }\n    }"}
{"idx": 569, "target": 1, "func": "public long remove(long socket) {\n            long result = 0;\n            for (int i = 0; i < size; i++) {\n                if (sockets[i] == socket) {\n                    result = timeouts[i];\n                    sockets[i] = sockets[size - 1];\n                    timeouts[i] = timeouts[size - 1];\n                    size--;\n                    break;\n                }\n            }\n            return result;\n        }"}
{"idx": 570, "target": 0, "func": "public void add(long socket, long timeout) {\n            sockets[size] = socket;\n            timeouts[size] = timeout;\n            size++;\n        }"}
{"idx": 571, "target": 1, "func": "@Override\n        public T get() throws InterruptedException, ExecutionException {\n            completionLatch.await();\n            if (throwable != null) {\n                throw new ExecutionException(throwable);\n            }\n            return result;\n        }"}
{"idx": 572, "target": 0, "func": "@Override\n        public void run() {\n            long written = 0;\n\n            try {\n                for (int i = offset; i < offset + length; i++) {\n                    ByteBuffer src = srcs[i];\n                    while (src.hasRemaining()) {\n                        socketWriteBuffer.clear();\n\n                        // Encrypt the data\n                        SSLEngineResult r = sslEngine.wrap(src, socketWriteBuffer);\n                        written += r.bytesConsumed();\n                        Status s = r.getStatus();\n\n                        if (s == Status.OK || s == Status.BUFFER_OVERFLOW) {\n                            // Need to write out the bytes and may need to read from\n                            // the source again to empty it\n                        } else {\n                            // Status.BUFFER_UNDERFLOW - only happens on unwrap\n                            // Status.CLOSED - unexpected\n                            throw new IllegalStateException(sm.getString(\n                                    \"asyncChannelWrapperSecure.statusWrap\"));\n                        }\n\n                        // Check for tasks\n                        if (r.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                            Runnable runnable = sslEngine.getDelegatedTask();\n                            while (runnable != null) {\n                                runnable.run();\n                                runnable = sslEngine.getDelegatedTask();\n                            }\n                        }\n\n                        socketWriteBuffer.flip();\n\n                        // Do the write\n                        int toWrite = r.bytesProduced();\n                        while (toWrite > 0) {\n                            Future<Integer> f =\n                                    socketChannel.write(socketWriteBuffer);\n                            Integer socketWrite = f.get();\n                            toWrite -= socketWrite.intValue();\n                        }\n                    }\n                }\n\n\n                if (writing.compareAndSet(true, false)) {\n                    future.complete(Long.valueOf(written));\n                } else {\n                    future.fail(new IllegalStateException(sm.getString(\n                            \"asyncChannelWrapperSecure.wrongStateWrite\")));\n                }\n            } catch (Exception e) {\n                future.fail(e);\n            }\n        }"}
{"idx": 573, "target": 0, "func": "@Override\n        public void run() {\n            long written = 0;\n\n            try {\n                for (int i = offset; i < offset + length; i++) {\n                    ByteBuffer src = srcs[i];\n                    while (src.hasRemaining()) {\n                        socketWriteBuffer.clear();\n\n                        // Encrypt the data\n                        SSLEngineResult r = sslEngine.wrap(src, socketWriteBuffer);\n                        written += r.bytesConsumed();\n                        Status s = r.getStatus();\n\n                        if (s == Status.OK || s == Status.BUFFER_OVERFLOW) {\n                            // Need to write out the bytes and may need to read from\n                            // the source again to empty it\n                        } else {\n                            // Status.BUFFER_UNDERFLOW - only happens on unwrap\n                            // Status.CLOSED - unexpected\n                            throw new IllegalStateException(sm.getString(\n                                    \"asyncChannelWrapperSecure.statusWrap\"));\n                        }\n\n                        // Check for tasks\n                        if (r.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                            Runnable runnable = sslEngine.getDelegatedTask();\n                            while (runnable != null) {\n                                runnable.run();\n                                runnable = sslEngine.getDelegatedTask();\n                            }\n                        }\n\n                        socketWriteBuffer.flip();\n\n                        // Do the write\n                        int toWrite = r.bytesProduced();\n                        while (toWrite > 0) {\n                            Future<Integer> f =\n                                    socketChannel.write(socketWriteBuffer);\n                            Integer socketWrite = f.get();\n                            toWrite -= socketWrite.intValue();\n                        }\n                    }\n                }\n\n\n                if (writing.compareAndSet(true, false)) {\n                    future.complete(Long.valueOf(written));\n                } else {\n                    future.fail(new IllegalStateException(sm.getString(\n                            \"asyncChannelWrapperSecure.wrongStateWrite\")));\n                }\n            } catch (Exception e) {\n                future.fail(e);\n            }\n        }"}
{"idx": 574, "target": 1, "func": "@Override\n    public Session connectToServer(Object pojo, URI path)\n            throws DeploymentException {\n\n        ClientEndpoint annotation =\n                pojo.getClass().getAnnotation(ClientEndpoint.class);\n        if (annotation == null) {\n            throw new DeploymentException(\n                    sm.getString(\"wsWebSocketContainer.missingAnnotation\",\n                            pojo.getClass().getName()));\n        }\n\n        Endpoint ep = new PojoEndpointClient(pojo, annotation.decoders());\n\n        Class<? extends ClientEndpointConfig.Configurator> configuratorClazz =\n                pojo.getClass().getAnnotation(\n                        ClientEndpoint.class).configurator();\n\n        ClientEndpointConfig.Configurator configurator = null;\n        if (!ClientEndpointConfig.Configurator.class.equals(\n                configuratorClazz)) {\n            try {\n                configurator = configuratorClazz.newInstance();\n            } catch (InstantiationException | IllegalAccessException e) {\n                throw new DeploymentException(sm.getString(\n                        \"wsWebSocketContainer.defaultConfiguratorFail\"), e);\n            }\n        }\n\n        ClientEndpointConfig config = ClientEndpointConfig.Builder.create().\n                configurator(configurator).\n                decoders(Arrays.asList(annotation.decoders())).\n                encoders(Arrays.asList(annotation.encoders())).\n                build();\n        return connectToServer(ep, config, path);\n    }"}
{"idx": 575, "target": 0, "func": "private SSLEngine createSSLEngine(Map<String,Object> userProperties)\n            throws DeploymentException {\n\n        try {\n            // See if a custom SSLContext has been provided\n            SSLContext sslContext =\n                    (SSLContext) userProperties.get(SSL_CONTEXT_PROPERTY);\n\n            if (sslContext == null) {\n                // Create the SSL Context\n                sslContext = SSLContext.getInstance(\"TLS\");\n\n                // Trust store\n                String sslTrustStoreValue =\n                        (String) userProperties.get(SSL_TRUSTSTORE_PROPERTY);\n                if (sslTrustStoreValue != null) {\n                    String sslTrustStorePwdValue = (String) userProperties.get(\n                            SSL_TRUSTSTORE_PWD_PROPERTY);\n                    if (sslTrustStorePwdValue == null) {\n                        sslTrustStorePwdValue = SSL_TRUSTSTORE_PWD_DEFAULT;\n                    }\n\n                    File keyStoreFile = new File(sslTrustStoreValue);\n                    KeyStore ks = KeyStore.getInstance(\"JKS\");\n                    try (InputStream is = new FileInputStream(keyStoreFile)) {\n                        ks.load(is, sslTrustStorePwdValue.toCharArray());\n                    }\n\n                    TrustManagerFactory tmf = TrustManagerFactory.getInstance(\n                            TrustManagerFactory.getDefaultAlgorithm());\n                    tmf.init(ks);\n\n                    sslContext.init(null, tmf.getTrustManagers(), null);\n                } else {\n                    sslContext.init(null, null, null);\n                }\n            }\n\n            SSLEngine engine = sslContext.createSSLEngine();\n\n            String sslProtocolsValue =\n                    (String) userProperties.get(SSL_PROTOCOLS_PROPERTY);\n            if (sslProtocolsValue != null) {\n                engine.setEnabledProtocols(sslProtocolsValue.split(\",\"));\n            }\n\n            engine.setUseClientMode(true);\n\n            return engine;\n        } catch (Exception e) {\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.sslEngineFail\"), e);\n        }\n    }"}
{"idx": 576, "target": 1, "func": "private List<String> generateExtensionHeaders(List<Extension> extensions) {\n        List<String> result = new ArrayList<>(extensions.size());\n        for (Extension extension : extensions) {\n            StringBuilder header = new StringBuilder();\n            header.append(extension.getName());\n            for (Extension.Parameter param : extension.getParameters()) {\n                header.append(';');\n                header.append(param.getName());\n                String value = param.getValue();\n                if (value != null && value.length() > 0) {\n                    header.append('=');\n                    header.append(value);\n                }\n            }\n        }\n        return result;\n    }"}
{"idx": 577, "target": 0, "func": "@Override\n    public void onOpen(Session session, EndpointConfig endpointConfig) {\n\n        ServerEndpointConfig sec = (ServerEndpointConfig) endpointConfig;\n\n        Object pojo;\n        try {\n            pojo = sec.getConfigurator().getEndpointInstance(\n                    sec.getEndpointClass());\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"pojoEndpointServer.getPojoInstanceFail\",\n                    sec.getEndpointClass().getName()), e);\n        }\n        setPojo(pojo);\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String,String> pathParameters =\n                (Map<String, String>) sec.getUserProperties().get(\n                        POJO_PATH_PARAM_KEY);\n        setPathParameters(pathParameters);\n\n        PojoMethodMapping methodMapping =\n                (PojoMethodMapping) sec.getUserProperties().get(\n                        POJO_METHOD_MAPPING_KEY);\n        setMethodMapping(methodMapping);\n\n        doOnOpen(session, endpointConfig);\n    }"}
{"idx": 578, "target": 0, "func": "@Override\n            public void run() {\n                try {\n\n                    // Create a new Player and add it to the room.\n                    try {\n                        player = room.createAndAddPlayer(client);\n                    } catch (IllegalStateException ex) {\n                        // Probably the max. number of players has been\n                        // reached.\n                        client.sendMessage(new StringWebsocketMessage(\n                                \"0\" + ex.getLocalizedMessage()));\n                        // Close the connection.\n                        client.close();\n                    }\n\n                } catch (RuntimeException ex) {\n                    log.error(\"Unexpected exception: \" + ex.toString(), ex);\n                }\n            }"}
